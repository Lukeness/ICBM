/*****************************************************************************
* Model: icbm.qm
* File:  ./console.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::console.c} ..........................................................*/
/* Interactive Controller for Brushless Motors serial console AO */
#include "qpn_port.h"
#include "icbm.h"
#include "bsp.h"
#include "libpic30.h"
#include <stdlib.h>
#include <ctype.h>

// A4960

//- Access to 'Limits' fields
extern FIELD const CommBlankTime;
extern FIELD const BlankTime;
extern FIELD const DeadTime;
extern FIELD const CurrentSenseRefRatio;
extern FIELD const VdsThreshold;

#ifdef UNDEF

//- Access to 'Limits' fields
extern ITEM const A4960_CommBlankTime;
extern ITEM const A4960_BlankTime;
extern ITEM const A4960_DeadTime;
extern ITEM const A4960_CurrentSenseRefRatio;
extern ITEM const A4960_VdsThreshold;

#endif

//- Access to 'Run' fields
extern FIELD const FixedOffTime;
extern FIELD const PhaseAdvance;
extern FIELD const BemfHyst;
extern FIELD const BemfWindow;
extern FIELD const Brake;
extern FIELD const Direction;
extern FIELD const Run;

//- Access to 'Startup' fields
extern FIELD const HoldTorque;
extern FIELD const HoldTime;
extern FIELD const EndCommTime;
extern FIELD const StartCommTime;
extern FIELD const ForcedCommTorque;
extern FIELD const RampRate;

//- Access to 'Flags' fields
extern FIELD const VaFlag;
extern FIELD const VbFlag;
extern FIELD const VcFlag;
extern FIELD const AhFlag;
extern FIELD const AlFlag;
extern FIELD const BhFlag;
extern FIELD const BlFlag;
extern FIELD const ChFlag;
extern FIELD const ClFlag;

//- Access to 'Misc' fields
extern FIELD const TorqueCtlMethod;
extern FIELD const EnableStopOnFail;
extern FIELD const DiagOutput;
extern FIELD const RestartControl;
extern FIELD const TwFlag;
extern FIELD const TsFlag;
extern FIELD const LosFlag;

//- Access to PWM
extern ITEM const PWM_Freq;
extern ITEM const PWM_Duty;

#define BAUD_RATE_CONSOLE 115200UL
//Console TX buffer size - must be power of 2
#define CONSOLE_BUFSIZE 64
#define CONSOLE_BUFMASK ( CONSOLE_BUFSIZE - 1 )

#if ( CONSOLE_BUFSIZE & CONSOLE_BUFMASK )
#error Serial Tx Buffer size is not a power of 2
#endif

//#define CONSOLE_RX_PIN _RB2
#define CONSOLE_RX_TRIS _TRISB2

#define ROLL_TOUT BSP_TICKS_PER_SEC/10   //whirling star animation
#define STAT_TOUT BSP_TICKS_PER_SEC/5    //status line update rate


//LED times
#define RUN_ON_TIME  BSP_TICKS_PER_SEC/50
#define RUN_OFF_TIME BSP_TICKS_PER_SEC*3

#define ALARM_ON_TIME  BSP_TICKS_PER_SEC/20
#define ALARM_OFF_TIME BSP_TICKS_PER_SEC/20

/* Variables */
//Serial console
const char* consoleBuf[CONSOLE_BUFSIZE];
uint8_t consoleHead;
volatile uint8_t consoleTail;    //interrupt changes this

static const char* const crlf = "\r\n";
static const char* const space = " ";

/*-- Main Menu */
const char* menuMain[] =
    { "Setup", "Mess", "Tune" };
#define MENU_MAIN_CNT Q_DIM(menuMain)

/*-- Setup Menu and accompanying menu item arrays */
const char* const menuSetup[] =
    { "Startup", "Ui" };
#define MENU_SETUP_CNT Q_DIM(menuSetup)

const ITEM* const controlItems[] = {&PWM_Freq};
#define CONTROL_CNT Q_DIM(controlItems)

const ITEM* const uiItems[] = {};
#define UI_CNT Q_DIM(uiItems)

/*- Mess Menu and accompanying menu item arrays */
const char* const menuMess[] = {"Limits","Run","Startup","Flags","Misc"};
#define MENU_MESS_CNT Q_DIM(menuMess)

const FIELD* const limitsFields[] = {&CommBlankTime,&BlankTime,&DeadTime,
    &CurrentSenseRefRatio, &VdsThreshold};
#define LIMITS_CNT Q_DIM(limitsFields)

const FIELD* const runFields[] = {&FixedOffTime, &PhaseAdvance, &BemfHyst,
     &BemfWindow, &Brake, &Direction, &Run};
#define RUN_CNT Q_DIM(runFields)



#ifdef UNDEF

const ITEM* const runItems[] =
    {&A4960_FixedOffTime, &A4960_PhaseAdvance, &A4960_BemfHyst,
     &A4960_BemfWindow, &A4960_Brake, &A4960_Direction, &A4960_Run};
#define RUN_CNT Q_DIM(runItems)

#endif

const FIELD* const startupFields[] =
    {&HoldTorque, &HoldTime, &EndCommTime,
     &StartCommTime, &ForcedCommTorque, &RampRate};
#define STARTUP_CNT Q_DIM(startupFields)

const FIELD* const flagsFields[] =
    {&VaFlag, &VbFlag, &VcFlag, &AhFlag,
     &AlFlag, &BhFlag, &BlFlag, &ChFlag,
     &ClFlag};
#define FLAGS_CNT Q_DIM(flagsFields)

const FIELD* const miscFields[] =
    {&TorqueCtlMethod, &EnableStopOnFail, &DiagOutput,
     &RestartControl, &TwFlag, &TsFlag, &LosFlag};
#define MISC_CNT Q_DIM(miscFields)

const char* const menuTune[]={"Tune","Tune"};
#define MENU_TUNE_CNT Q_DIM(menuTune)

/* local objects -----------------------------------------------------------*/

//en.wikipedia.org/wiki/Blinkenlights
/*${AOs::Blinke} ...........................................................*/
typedef struct Blinke {
/* protected: */
    QMsm super;

/* private: */
} Blinke;
extern uint16_t Blinke_cnt;
extern uint8_t Blinke_on_time;
extern uint16_t Blinke_off_time;

/* protected: */
static QState Blinke_initial(Blinke * const me);
static QState Blinke_DER_BLINKENLICHT  (Blinke * const me);
static QMState const Blinke_DER_BLINKENLICHT_s = {
    (QMState const *)0, /* superstate (top) */
    Q_STATE_CAST(&Blinke_DER_BLINKENLICHT),
    Q_ACTION_CAST(0), /* no entry action */
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Blinke_Off  (Blinke * const me);
static QMState const Blinke_Off_s = {
    &Blinke_DER_BLINKENLICHT_s, /* superstate */
    Q_STATE_CAST(&Blinke_Off),
    Q_ACTION_CAST(0), /* no entry action */
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Blinke_On  (Blinke * const me);
static QState Blinke_On_e(Blinke * const me);
static QState Blinke_On_x(Blinke * const me);
static QMState const Blinke_On_s = {
    &Blinke_DER_BLINKENLICHT_s, /* superstate */
    Q_STATE_CAST(&Blinke_On),
    Q_ACTION_CAST(&Blinke_On_e),
    Q_ACTION_CAST(&Blinke_On_x),
    Q_ACTION_CAST(0)  /* no intitial tran. */
};

/*${AOs::Console} ..........................................................*/
typedef struct Console {
/* protected: */
    QMActive super;

/* private: */
    uint8_t menuselect;
    uint16_t rpm;

/* public: */
    uint16_t diag;
    Blinke blinke;
} Console;

/* private: */
static void Console_printStr(const char* str);
static void Console_printNum(
    uint32_t num,
    uint8_t base,
    uint8_t point);
static void Console_printWhirlingStar(void);
static void Console_printMenuTitle(uint8_t count, const char* const* menu);
static void Console_printMenuItems(Console * const me, FIELD** field, uint8_t cnt);
static void Console_handleMenuItems(
    Console * const me,
    uint8_t key,
    FIELD** field,
    uint8_t cnt);
static void Console_Blinke_ctor(Blinke* const me);

/* protected: */
static QState Console_initial(Console * const me);
static QState Console_Session  (Console * const me);
static QState Console_Session_e(Console * const me);
static QMState const Console_Session_s = {
    (QMState const *)0, /* superstate (top) */
    Q_STATE_CAST(&Console_Session),
    Q_ACTION_CAST(&Console_Session_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Main  (Console * const me);
static QState Console_Main_e(Console * const me);
static QState Console_Main_x(Console * const me);
static QMState const Console_Main_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Main),
    Q_ACTION_CAST(&Console_Main_e),
    Q_ACTION_CAST(&Console_Main_x),
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Idle  (Console * const me);
static QState Console_Idle_e(Console * const me);
static QState Console_Idle_x(Console * const me);
static QMState const Console_Idle_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Idle),
    Q_ACTION_CAST(&Console_Idle_e),
    Q_ACTION_CAST(&Console_Idle_x),
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Setup  (Console * const me);
static QState Console_Setup_e(Console * const me);
static QMState const Console_Setup_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Setup),
    Q_ACTION_CAST(&Console_Setup_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Mess  (Console * const me);
static QState Console_Mess_e(Console * const me);
static QState Console_Mess_x(Console * const me);
static QMState const Console_Mess_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Mess),
    Q_ACTION_CAST(&Console_Mess_e),
    Q_ACTION_CAST(&Console_Mess_x),
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Tune  (Console * const me);
static QState Console_Tune_e(Console * const me);
static QMState const Console_Tune_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Tune),
    Q_ACTION_CAST(&Console_Tune_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Limits  (Console * const me);
static QState Console_Limits_e(Console * const me);
static QMState const Console_Limits_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Limits),
    Q_ACTION_CAST(&Console_Limits_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Run  (Console * const me);
static QState Console_Run_e(Console * const me);
static QMState const Console_Run_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Run),
    Q_ACTION_CAST(&Console_Run_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Startup  (Console * const me);
static QState Console_Startup_e(Console * const me);
static QMState const Console_Startup_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Startup),
    Q_ACTION_CAST(&Console_Startup_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Misc  (Console * const me);
static QState Console_Misc_e(Console * const me);
static QMState const Console_Misc_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Misc),
    Q_ACTION_CAST(&Console_Misc_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Flags  (Console * const me);
static QState Console_Flags_e(Console * const me);
static QMState const Console_Flags_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Flags),
    Q_ACTION_CAST(&Console_Flags_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_Control  (Console * const me);
static QState Console_Control_e(Console * const me);
static QMState const Console_Control_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_Control),
    Q_ACTION_CAST(&Console_Control_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};
static QState Console_UI  (Console * const me);
static QState Console_UI_e(Console * const me);
static QMState const Console_UI_s = {
    &Console_Session_s, /* superstate */
    Q_STATE_CAST(&Console_UI),
    Q_ACTION_CAST(&Console_UI_e),
    Q_ACTION_CAST(0), /* no exit action */
    Q_ACTION_CAST(0)  /* no intitial tran. */
};


/* global objects ----------------------------------------------------------*/
Console AO_Console;

/* Active object definition ================================================*/
/*${AOs::Console_ctor} .....................................................*/
void Console_ctor(void) {
    Console *me = &AO_Console;
    QMActive_ctor(&me->super, Q_STATE_CAST(&Console_initial));

    Console_Blinke_ctor(&me->blinke);
    QMSM_INIT((QMsm*)&me->blinke);

    /* Initialize console hardware */

           U1MODE = 0x0008;                                /* enable high baud rate */
           U1STAbits.UTXISEL1 = 1;
           U1BRG  = ((FCY / 4 / BAUD_RATE_CONSOLE) - 1);    /* baud rate generator */

           _U1TXIP = 1; //serial interrupt priority
           _U1RXIP = 1;
           _U1ERIP = 1;
           U1MODEbits.UARTEN = 1;    //UART then Tx - in that order!
           U1STAbits.UTXEN   = 1;

    {    uint8_t tmpdata;
           tmpdata = U1RXREG;       //clear RX errors
    }
           U1STAbits.FERR = 0;
           U1STAbits.OERR = 0;

           CONSOLE_RX_TRIS = 1;    //set RX to input. todo - make less hardcoded

           consoleTail = 0;
           consoleHead = 0;

            //do not enable interrupts here - do it in QF_onStartup()
            _U1RXIF = 0;
            _U1ERIF = 0;

}
/*${AOs::Console} ..........................................................*/
/*${AOs::Console::printStr} ................................................*/
static void Console_printStr(const char* str) {
    uint8_t tmphead = consoleHead + 1;

    #if CONSOLE_BUFMASK < 255
    tmphead &= CONSOLE_BUFMASK;
    #endif

    while(tmphead == consoleTail) {}     //this line blocks!

    consoleBuf[tmphead] = str;
    consoleHead = tmphead;

    if( _U1TXIE == 0) {    //trigger interrupt
        _U1TXIF = 1;
        _U1TXIE = 1;
    }

    return;
}
/*${AOs::Console::printNum} ................................................*/
static void Console_printNum(
    uint32_t num,
    uint8_t base,
    uint8_t point)
{
    #define CHAR_BUFSIZE 33
    const char* const numchars[] = {"0","1","2","3","4","5","6","7","8","9",
        "A","B","C","D","E","F"};
    const char* buf[CHAR_BUFSIZE];
    const char** pStr = &(buf[CHAR_BUFSIZE-1]);

    do {
        *(--pStr) = numchars[num % base];
        num /= base;
        } while( num != 0 );

    while( pStr < &buf[CHAR_BUFSIZE-1] ) {    //copy the buffer into the queue
        if((&buf[CHAR_BUFSIZE-1] - pStr) == point) {
            Console_printStr(".");                       //print decimal point
        }
        Console_printStr(*pStr++);
    }
}
/*${AOs::Console::printWhirlingStar} .......................................*/
static void Console_printWhirlingStar(void) {
    #define IDX_MASK 3
    const char* const rollchar[4] = {"/","-","\\","|"};
    static uint8_t idx = 0;

    Console_printStr("\x08");    //backspace

    Console_printStr(rollchar[idx++]);

    idx &= IDX_MASK;
}
/*${AOs::Console::printMenuTitle} ..........................................*/
static void Console_printMenuTitle(uint8_t count, const char* const* menu) {
    uint8_t i;

    Console_printStr(crlf);

    for(i = 0; i <= count; i++) {
        Console_printNum(i,10,0U);
        Console_printStr(". ");

        if (i == 0) {
            Console_printStr("Back");
        }
        else {
            Console_printStr(menu[i-1]);
        }

        Console_printStr(crlf);
    }//for...

    Console_printStr(crlf);
}
/*${AOs::Console::printMenuItems} ..........................................*/
static void Console_printMenuItems(Console * const me, FIELD** field, uint8_t cnt) {
    uint8_t i;

    Console_printStr("\r\nPress number to select field,"
                     "\r\nthen w,a,s,d to change it."
                     "\r\n\n0. Back");

    //Console_printStr("\r\nPress number to select field,");
    //Console_printStr("\r\nthen w,a,s,d to change it");
    //Console_printStr("\r\n\n0. Back");

    Console_printStr(crlf);

    for(i = 0; i < cnt; i++) {
        if(i+1 == me->menuselect) {    //highlight
            Console_printStr(">>> ");
        } else {
            Console_printNum(i+1, 10, 0U);
            Console_printStr(". ");
        }

        Console_printStr(field[i]->title);    //field name

        Console_printStr(" [");
        Console_printNum(getField(&(*field[i])), 2, 0U);    //field contents, binary

        Console_printStr("], ");

        //if(field[i]->conv) {    //conversion needed
            Console_printNum(field[i]->conv(&(*field[i])),
                             10,
                             field[i]->point);           //field contents, converted
        //} else {
        //    Console_printNum(getField(&(*field[i])),
        //                     10,
        //                     field[i]->point);             //field contents, decimal
        //}

        Console_printStr(space);
        Console_printStr(field[i]->unit);        //field unit
        Console_printStr(crlf);
    }
    Console_printStr(crlf);
}
/*${AOs::Console::handleMenuItems} .........................................*/
static void Console_handleMenuItems(
    Console * const me,
    uint8_t key,
    FIELD** field,
    uint8_t cnt)
{
    uint8_t tmpdata = atoi((const char*)&key);

    if(isdigit(key)) {    //numeric
        if(tmpdata > cnt) {
            return;    //wrong key, do not handle
        }
        else {
            me->menuselect = tmpdata;    //remember selection
            return;
        }
    }

    if(me->menuselect == 0) {
        return;    //no further processing necessary
    }

    tmpdata = getField(&(*field[me->menuselect-1]));

    if(key == 'w' || key == 'W') {    //increment
        tmpdata++;
    }

    if(key == 's' || key == 'S') {    //decrement
        tmpdata--;
    }

    uint16_t tmplen = field[me->menuselect-1]->mask;

    while((tmplen & 0x01) == 0 ) { //LSB eq zero
        tmplen >>= 1;
    }

    tmpdata &= tmplen;

    setField(tmpdata,&(*field[me->menuselect-1]));
}
/*${AOs::Console::Blinke_ctor} .............................................*/
static void Console_Blinke_ctor(Blinke* const me) {
    QMsm_ctor(&me->super, Q_STATE_CAST(&Blinke_initial));
}
/*${AOs::Console::SM} ......................................................*/
static QState Console_initial(Console * const me) {
    static struct {
        QMState const *target;
        QActionHandler act[3];
    } const tatbl_ = { /* transition-action table */
        &Console_Idle_s, /* target state */
        {
            Q_ACTION_CAST(&Console_Session_e), /* entry */
            Q_ACTION_CAST(&Console_Idle_e), /* entry */
            Q_ACTION_CAST(0) /* zero terminator */
        }
    };
    /* ${AOs::Console::SM::initial} */
    QActive_armX((QActive*)me, 0U, ROLL_TOUT);
    return QM_TRAN_INIT(&tatbl_);
}
/*${AOs::Console::SM::Session} .............................................*/
/* ${AOs::Console::SM::Session} */
static QState Console_Session_e(Console * const me) {
    //QActive_armX((QActive*)me, 1U, TACH_TOUT);
    return QM_ENTRY(&Console_Session_s);
}
/* ${AOs::Console::SM::Session} */
static QState Console_Session(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::WCOL} */
        case WCOL_SIG: {
            Console_printStr("\r\nA4960 SPI Write collision");
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::FF} */
        case FF_SIG: {
            //Fault reported

            //uint8_t i =
            //    A4960_TwFlag.get((struct item_t*)&A4960_TwFlag);

            //me->diag =
            //    A4960_TwFlag.set(i, (struct item_t*)&A4960_TwFlag);

            //uint8_t i = getField((struct field_t*)&TwFlag);
            //me->diag = setField(i, (struct field_t*)&TwFlag);

            //Console_printNum(Q_PAR(me),16,0U);

            //Console_printStr("\r\nA4960 fault");
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::TICK} */
        case TICK_SIG: {
            Q_SIG(&me->blinke) = Q_SIG(me);
            QMSM_DISPATCH((QMsm*)&me->blinke);
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::TACHO} */
        case TACHO_SIG: {
            me->rpm = Q_PAR(me);
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            static const char* const diag_flags[] =
                {"FF ","POR ","VR ","?? ","TW ","TS ","LOS ","VA ","VB ",
                "VC ","AH ","AL ","BH ","BL ","CH ","CL "};

            uint32_t tmp32;
            /* Status line output */
            Console_printStr("\rSpeed: ");
            Console_printNum(me->rpm, 10, 0U);

            //run flags
            Console_printStr(" [ ");

            if(getField((struct field_t*)&Run)) {    //run flag up
               Console_printStr("RUN ");
            }
            if(getField((struct field_t*)&Brake)) {    //brake flag up
                Console_printStr("BRK ");
            }
            if(getField((struct field_t*)&Direction)) {//dir flag up
                Console_printStr("DIR ");
            }

            Console_printStr("]");

            Console_printStr(" Duty: ");

            //tmp32 = ((PWM_getDuty() *100)/PWM_getPeriod()); //one tenth of a percent
            //Console_printNum(tmp32, 10, 1U);
            tmp32 = PWM_getDuty();
            tmp32 *= 1000;
            tmp32 /= PWM_getPeriod();
            Console_printNum(tmp32,10,1U);



            Console_printStr("%");



            //diagnostic flags. I need to write to a register to get those
            uint16_t tmpdata = A4960_xfer(A4960_RUN_RD,0U);         //read RUN register
            uint16_t tmpdiag = A4960_xfer(A4960_RUN_WR,tmpdata);    //read diagnostic

            if(tmpdiag) {
                uint8_t i;
                Console_printStr(" [ Flags: ");

                for(i = 0; i < 16; i++) {
                    if(tmpdiag & 0x8000) {    //print flag if set
                        Console_printStr(" ");
                        Console_printStr(diag_flags[i]);
                    }
                    tmpdiag <<=1;
                }
                Console_printStr("]");
            }//if( tmpdiag...

            Console_printStr("   ");
            QActive_armX(&me->super, 0U, STAT_TOUT);
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::RBUT_PRESS} */
        case RBUT_PRESS_SIG: {
            //Console_printStr("\r\n\r\nRun Button Pressed\r\n");

            uint8_t tmpdata = getField((struct field_t*)&Run);

            tmpdata = !tmpdata;

            setField(tmpdata, (struct field_t*)&Run);
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::ENCI} */
        case ENCI_SIG: {
            uint16_t tmpdata = PWM_getDuty();

            if( ++tmpdata >= PWM_getPeriod() ) {
                tmpdata = PWM_getPeriod();
            }

            PWM_setDuty( tmpdata );
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::ENCD} */
        case ENCD_SIG: {
            uint16_t tmpdata = PWM_getDuty();

            if( --tmpdata < 1 ) {
                tmpdata = 1;
            }

            PWM_setDuty( tmpdata );
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::BBUT_PRESS} */
        case BBUT_PRESS_SIG: {
            uint8_t tmpdata = getField((struct field_t*)&Brake);

            tmpdata = !tmpdata;

            setField(tmpdata, (struct field_t*)&Brake);
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::EBUT_PRESS} */
        case EBUT_PRESS_SIG: {
            Console_printStr("\r\n\r\nEnc Button Pressed\r\n");
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::EBUT_RELEASE} */
        case EBUT_RELEASE_SIG: {
            Console_printStr("\r\n\r\nEnc Button Released\r\n");
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::KBD_KEY} */
        case KBD_KEY_SIG: {
            static struct {
                QMState const *target;
                QActionHandler act[2];
            } const tatbl_ = { /* transition-action table */
                &Console_Main_s, /* target state */
                {
                    Q_ACTION_CAST(&Console_Main_e), /* entry */
                    Q_ACTION_CAST(0) /* zero terminator */
                }
            };
            Console_printStr("\r\nKey Pressed At the TOP");
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::Main} .......................................*/
/* ${AOs::Console::SM::Session::Main} */
static QState Console_Main_e(Console * const me) {
    Console_printStr("\r\nMain Menu: ");
    Console_printMenuTitle(MENU_MAIN_CNT, menuMain);
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return QM_ENTRY(&Console_Main_s);
}
/* ${AOs::Console::SM::Session::Main} */
static QState Console_Main_x(Console * const me) {
    me->menuselect = 0;    //reset menu selection
    return QM_EXIT(&Console_Main_s);
}
/* ${AOs::Console::SM::Session::Main} */
static QState Console_Main(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::Main::KBD_KEY} */
        case KBD_KEY_SIG: {
            //Console_printStr(me,"\r\nKey Pressed");

            //U1TXREG = Q_PAR(me);

            //U1TXREG = 'A';
            /* ${AOs::Console::SM::Session::Main::KBD_KEY::[1]} */
            if ((uint8_t)(Q_PAR(me)) == '1') {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &Console_Setup_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Main_x), /* exit */
                        Q_ACTION_CAST(&Console_Setup_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Main::KBD_KEY::[2]} */
            else if ((uint8_t)(Q_PAR(me)) == '2') {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &Console_Mess_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Main_x), /* exit */
                        Q_ACTION_CAST(&Console_Mess_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Main::KBD_KEY::[3]} */
            else if ((uint8_t)(Q_PAR(me)) == '3') {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &Console_Tune_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Main_x), /* exit */
                        Q_ACTION_CAST(&Console_Tune_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            else {
                status_ = QM_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::Idle} .......................................*/
/* ${AOs::Console::SM::Session::Idle} */
static QState Console_Idle_e(Console * const me) {
    //Console_printStr("\r\nPress any key to enter console..  ");
    //QActive_armX((QActive*)me, 1U, TACHO_TOUT);
    return QM_ENTRY(&Console_Idle_s);
}
/* ${AOs::Console::SM::Session::Idle} */
static QState Console_Idle_x(Console * const me) {
    //QActive_disarmX(&me->super, 0U);
    return QM_EXIT(&Console_Idle_s);
}
/* ${AOs::Console::SM::Session::Idle} */
static QState Console_Idle(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::Idle::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            QActive_armX(&me->super, 0U, ROLL_TOUT);
            Console_printWhirlingStar();
            status_ = QM_HANDLED();
            break;
        }
        /* ${AOs::Console::SM::Session::Idle::KBD_KEY} */
        case KBD_KEY_SIG: {
            static struct {
                QMState const *target;
                QActionHandler act[3];
            } const tatbl_ = { /* transition-action table */
                &Console_Main_s, /* target state */
                {
                    Q_ACTION_CAST(&Console_Idle_x), /* exit */
                    Q_ACTION_CAST(&Console_Main_e), /* entry */
                    Q_ACTION_CAST(0) /* zero terminator */
                }
            };
            Console_printStr("\r\nInteractive Controller for Brushless Motors Console rev.");
            Console_printStr(REV);
            Console_printStr("\r\nCompiled on ");
            Console_printStr(__DATE__);
            Console_printStr(" at ");
            Console_printStr(__TIME__);
            Console_printStr(" using Microchip XC16 C compiler ver.");
            Console_printNum(__XC16_VERSION__, 10,0U);
            Console_printStr("\r\n\n");
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::Setup} ......................................*/
/* ${AOs::Console::SM::Session::Setup} */
static QState Console_Setup_e(Console * const me) {
    Console_printStr("\r\nSetup Menu:");
    Console_printMenuTitle(MENU_SETUP_CNT, menuSetup);
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return QM_ENTRY(&Console_Setup_s);
}
/* ${AOs::Console::SM::Session::Setup} */
static QState Console_Setup(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::Setup::KBD_KEY} */
        case KBD_KEY_SIG: {
            Console_printStr("\r\n");
            /* ${AOs::Console::SM::Session::Setup::KBD_KEY::[0]} */
            if ((uint8_t)(Q_PAR(me)) == '0') {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Main_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Main_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Setup::KBD_KEY::[1]} */
            else if ((uint8_t)(Q_PAR(me)) == '1') {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Control_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Control_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Setup::KBD_KEY::[2]} */
            else if ((uint8_t)(Q_PAR(me)) == '2') {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_UI_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_UI_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Setup::KBD_KEY::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Setup_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Setup_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::Mess} .......................................*/
/* ${AOs::Console::SM::Session::Mess} */
static QState Console_Mess_e(Console * const me) {
    Console_printStr("\r\nMess Menu:");
    Console_printMenuTitle(MENU_MESS_CNT, menuMess);
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return QM_ENTRY(&Console_Mess_s);
}
/* ${AOs::Console::SM::Session::Mess} */
static QState Console_Mess_x(Console * const me) {
    me->menuselect = 0;    //reset menu selection
    return QM_EXIT(&Console_Mess_s);
}
/* ${AOs::Console::SM::Session::Mess} */
static QState Console_Mess(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::Mess::KBD_KEY} */
        case KBD_KEY_SIG: {
            Console_printStr("\r\n");
            /* ${AOs::Console::SM::Session::Mess::KBD_KEY::[1]} */
            if ((uint8_t)(Q_PAR(me)) == '1') {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &Console_Limits_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_x), /* exit */
                        Q_ACTION_CAST(&Console_Limits_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Mess::KBD_KEY::[2]} */
            else if ((uint8_t)(Q_PAR(me)) == '2') {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &Console_Run_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_x), /* exit */
                        Q_ACTION_CAST(&Console_Run_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Mess::KBD_KEY::[3]} */
            else if ((uint8_t)(Q_PAR(me)) == '3') {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &Console_Startup_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_x), /* exit */
                        Q_ACTION_CAST(&Console_Startup_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Mess::KBD_KEY::[4]} */
            else if ((uint8_t)(Q_PAR(me)) == '4') {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &Console_Flags_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_x), /* exit */
                        Q_ACTION_CAST(&Console_Flags_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Mess::KBD_KEY::[5]} */
            else if ((uint8_t)(Q_PAR(me)) == '5') {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &Console_Misc_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_x), /* exit */
                        Q_ACTION_CAST(&Console_Misc_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Mess::KBD_KEY::[0]} */
            else if ((uint8_t)(Q_PAR(me)) == '0') {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &Console_Main_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_x), /* exit */
                        Q_ACTION_CAST(&Console_Main_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Mess::KBD_KEY::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[3];
                } const tatbl_ = { /* transition-action table */
                    &Console_Mess_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_x), /* exit */
                        Q_ACTION_CAST(&Console_Mess_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::Tune} .......................................*/
/* ${AOs::Console::SM::Session::Tune} */
static QState Console_Tune_e(Console * const me) {
    Console_printStr("\r\nTune Menu:");
    Console_printMenuTitle(MENU_TUNE_CNT, menuTune);
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return QM_ENTRY(&Console_Tune_s);
}
/* ${AOs::Console::SM::Session::Tune} */
static QState Console_Tune(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return status_;
}
/*${AOs::Console::SM::Session::Limits} .....................................*/
/* ${AOs::Console::SM::Session::Limits} */
static QState Console_Limits_e(Console * const me) {
    //Console_printItems(me, (ITEM**)limitsItems, LIMITS_CNT);
    Console_printMenuItems(me, (FIELD**)limitsFields, LIMITS_CNT);
    return QM_ENTRY(&Console_Limits_s);
}
/* ${AOs::Console::SM::Session::Limits} */
static QState Console_Limits(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::Limits::KBD_KEY} */
        case KBD_KEY_SIG: {
            /* ${AOs::Console::SM::Session::Limits::KBD_KEY::[0]} */
            if ((uint8_t)(Q_PAR(me)) == '0') {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Mess_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Limits::KBD_KEY::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Limits_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Limits_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                //Console_handleItems
                //    (me,(uint8_t)Q_PAR(me),(ITEM**)limitsItems, LIMITS_CNT);

                Console_handleMenuItems
                    (me,(uint8_t)Q_PAR(me),(FIELD**)limitsFields, LIMITS_CNT);
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::Run} ........................................*/
/* ${AOs::Console::SM::Session::Run} */
static QState Console_Run_e(Console * const me) {
    Console_printMenuItems(me, (FIELD**)runFields, RUN_CNT);
    return QM_ENTRY(&Console_Run_s);
}
/* ${AOs::Console::SM::Session::Run} */
static QState Console_Run(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::Run::KBD_KEY} */
        case KBD_KEY_SIG: {
            /* ${AOs::Console::SM::Session::Run::KBD_KEY::[0]} */
            if ((uint8_t)(Q_PAR(me)) == '0') {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Mess_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Run::KBD_KEY::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Run_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Run_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                Console_handleMenuItems
                    (me, (uint8_t)Q_PAR(me), (FIELD**)runFields, RUN_CNT);
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::Startup} ....................................*/
/* ${AOs::Console::SM::Session::Startup} */
static QState Console_Startup_e(Console * const me) {
    Console_printMenuItems
        (me, (FIELD**)startupFields, STARTUP_CNT);
    return QM_ENTRY(&Console_Startup_s);
}
/* ${AOs::Console::SM::Session::Startup} */
static QState Console_Startup(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::Startup::KBD_KEY} */
        case KBD_KEY_SIG: {
            /* ${AOs::Console::SM::Session::Startup::KBD_KEY::[0]} */
            if ((uint8_t)(Q_PAR(me)) == '0') {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Mess_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Startup::KBD_KEY::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Startup_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Startup_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                Console_handleMenuItems
                    (me, (uint8_t)Q_PAR(me), (FIELD**)startupFields,
                    STARTUP_CNT);
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::Misc} .......................................*/
/* ${AOs::Console::SM::Session::Misc} */
static QState Console_Misc_e(Console * const me) {
    Console_printMenuItems
        (me,(FIELD**)miscFields, MISC_CNT);

    return QM_ENTRY(&Console_Misc_s);
}
/* ${AOs::Console::SM::Session::Misc} */
static QState Console_Misc(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::Misc::KBD_KEY} */
        case KBD_KEY_SIG: {
            /* ${AOs::Console::SM::Session::Misc::KBD_KEY::[0]} */
            if ((uint8_t)(Q_PAR(me)) == '0') {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Mess_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Misc::KBD_KEY::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Misc_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Misc_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                Console_handleMenuItems
                    (me, (uint8_t)Q_PAR(me), (FIELD**)miscFields,
                    MISC_CNT);
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::Flags} ......................................*/
/* ${AOs::Console::SM::Session::Flags} */
static QState Console_Flags_e(Console * const me) {
    Console_printStr("\r\nUse 'Misc' menu for non-bridge related faults");

    Console_printMenuItems
        (me, (FIELD**)flagsFields, FLAGS_CNT);
    return QM_ENTRY(&Console_Flags_s);
}
/* ${AOs::Console::SM::Session::Flags} */
static QState Console_Flags(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::Flags::KBD_KEY} */
        case KBD_KEY_SIG: {
            /* ${AOs::Console::SM::Session::Flags::KBD_KEY::[0]} */
            if ((uint8_t)(Q_PAR(me)) == '0') {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Mess_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Mess_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Flags::KBD_KEY::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Flags_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Flags_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                Console_handleMenuItems
                    (me, (uint8_t)Q_PAR(me), (FIELD**)flagsFields,
                    FLAGS_CNT);
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::Control} ....................................*/
/* ${AOs::Console::SM::Session::Control} */
static QState Console_Control_e(Console * const me) {
    //Console_printItems(me, (ITEM**)controlItems, CONTROL_CNT);
    return QM_ENTRY(&Console_Control_s);
}
/* ${AOs::Console::SM::Session::Control} */
static QState Console_Control(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::Control::KBD_KEY} */
        case KBD_KEY_SIG: {
            /* ${AOs::Console::SM::Session::Control::KBD_KEY::[0]} */
            if ((uint8_t)(Q_PAR(me)) == '0') {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Setup_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Setup_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::Control::KBD_KEY::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Control_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Control_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                //Console_handleItems
                //    (me,(uint8_t)Q_PAR(me),(ITEM**)controlItems, CONTROL_CNT);
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Console::SM::Session::UI} .........................................*/
/* ${AOs::Console::SM::Session::UI} */
static QState Console_UI_e(Console * const me) {
    //Console_printItems(me, (ITEM**)uiItems, UI_CNT);
    return QM_ENTRY(&Console_UI_s);
}
/* ${AOs::Console::SM::Session::UI} */
static QState Console_UI(Console * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Console::SM::Session::UI::KBD_KEY} */
        case KBD_KEY_SIG: {
            /* ${AOs::Console::SM::Session::UI::KBD_KEY::[0]} */
            if ((uint8_t)(Q_PAR(me)) == '0') {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_Setup_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_Setup_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            /* ${AOs::Console::SM::Session::UI::KBD_KEY::[else]} */
            else {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Console_UI_s, /* target state */
                    {
                        Q_ACTION_CAST(&Console_UI_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                //Console_handleItems
                //    (me,(uint8_t)Q_PAR(me),(ITEM**)uiItems, UI_CNT);
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}


//en.wikipedia.org/wiki/Blinkenlights
/*${AOs::Blinke} ...........................................................*/
uint16_t Blinke_cnt;
uint8_t Blinke_on_time;
uint16_t Blinke_off_time;
/*${AOs::Blinke::SM} .......................................................*/
static QState Blinke_initial(Blinke * const me) {
    static struct {
        QMState const *target;
        QActionHandler act[2];
    } const tatbl_ = { /* transition-action table */
        &Blinke_On_s, /* target state */
        {
            Q_ACTION_CAST(&Blinke_On_e), /* entry */
            Q_ACTION_CAST(0) /* zero terminator */
        }
    };
    /* ${AOs::Blinke::SM::initial} */
    Blinke_on_time = RUN_ON_TIME;
    Blinke_off_time = RUN_OFF_TIME;
    return QM_TRAN_INIT(&tatbl_);
}
/*${AOs::Blinke::SM::DER_BLINKENLICHT} .....................................*/
/* ${AOs::Blinke::SM::DER_BLINKENLICHT} */
static QState Blinke_DER_BLINKENLICHT(Blinke * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Blinke::SM::DER_BLINKENLICHT::ALARM} */
        case ALARM_SIG: {
            static struct {
                QMState const *target;
                QActionHandler act[2];
            } const tatbl_ = { /* transition-action table */
                &Blinke_On_s, /* target state */
                {
                    Q_ACTION_CAST(&Blinke_On_e), /* entry */
                    Q_ACTION_CAST(0) /* zero terminator */
                }
            };
            Blinke_on_time = ALARM_ON_TIME;
            Blinke_off_time = ALARM_OFF_TIME;
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        /* ${AOs::Blinke::SM::DER_BLINKENLICHT::RUN} */
        case RUN_SIG: {
            static struct {
                QMState const *target;
                QActionHandler act[2];
            } const tatbl_ = { /* transition-action table */
                &Blinke_On_s, /* target state */
                {
                    Q_ACTION_CAST(&Blinke_On_e), /* entry */
                    Q_ACTION_CAST(0) /* zero terminator */
                }
            };
            Blinke_on_time = RUN_ON_TIME;
            Blinke_off_time = RUN_OFF_TIME;
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Blinke::SM::DER_BLINKENLICHT::Off} ................................*/
/* ${AOs::Blinke::SM::DER_BLINKENLICHT::Off} */
static QState Blinke_Off(Blinke * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Blinke::SM::DER_BLINKENLICHT::Off::TICK} */
        case TICK_SIG: {
            Blinke_cnt--;
            /* ${AOs::Blinke::SM::DER_BLINKENLICHT::Off::TICK::[Blinke_cnt==0]} */
            if (Blinke_cnt == 0) {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Blinke_On_s, /* target state */
                    {
                        Q_ACTION_CAST(&Blinke_On_e), /* entry */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            else {
                status_ = QM_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*${AOs::Blinke::SM::DER_BLINKENLICHT::On} .................................*/
/* ${AOs::Blinke::SM::DER_BLINKENLICHT::On} */
static QState Blinke_On_e(Blinke * const me) {
    LED_ON();
    Blinke_cnt = Blinke_on_time;
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return QM_ENTRY(&Blinke_On_s);
}
/* ${AOs::Blinke::SM::DER_BLINKENLICHT::On} */
static QState Blinke_On_x(Blinke * const me) {
    LED_OFF();
    Blinke_cnt = Blinke_off_time;
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return QM_EXIT(&Blinke_On_s);
}
/* ${AOs::Blinke::SM::DER_BLINKENLICHT::On} */
static QState Blinke_On(Blinke * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Blinke::SM::DER_BLINKENLICHT::On::TICK} */
        case TICK_SIG: {
            Blinke_cnt--;
            /* ${AOs::Blinke::SM::DER_BLINKENLICHT::On::TICK::[Blinke_cnt==0]} */
            if (Blinke_cnt == 0) {
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { /* transition-action table */
                    &Blinke_Off_s, /* target state */
                    {
                        Q_ACTION_CAST(&Blinke_On_x), /* exit */
                        Q_ACTION_CAST(0) /* zero terminator */
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            else {
                status_ = QM_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}


/*-- Interrupts */
/*${BSP::ISR::_U1RXInterrupt} ..............................................*/
void  __attribute__((__interrupt__, auto_psv)) _U1RXInterrupt(void) {
    uint8_t tmpdata;
    while( U1STAbits.URXDA == 1 ) {
        tmpdata = U1RXREG;
        QACTIVE_POST_X_ISR
            ((QActive*)&AO_Console, 1, KBD_KEY_SIG, tmpdata);
    }
    _U1RXIF = 0;
    //Input can be paced by disabling interrupt here
    // and re-enabling in &Console
}
/*${BSP::ISR::_U1TXInterrupt} ..............................................*/
void  __attribute__((__interrupt__, auto_psv)) _U1TXInterrupt(void) {
    static const char* pPrintStr = 0; //stores a string being printed

    while( U1STAbits.UTXBF == 0 ) {    //UART buffer available
        if( *pPrintStr ) {             //previous string not completed
            U1TXREG = *pPrintStr++;
        }//if( *pPrintStr...
        else {                         //get next string
            if( consoleHead != consoleTail ) {    //data available
                consoleTail++;
    #if CONSOLE_BUFMASK < 255
                consoleTail &= CONSOLE_BUFMASK;
    #endif //CONSOLE_TX_BUFMASK < 255

                 pPrintStr = consoleBuf[consoleTail];
            }
            else {              //queue empty
                _U1TXIE = 0;    //disable interrupt
                return;    //IF not cleared - bug?
             }
        }//else - get next string
    }//while( U2STAbits.UTXBF == 0...

    _U1TXIF = 0;    //clear interrupt
}
/*${BSP::ISR::_U1ErrInterrupt} .............................................*/
void  __attribute__((__interrupt__, auto_psv)) _U1ErrInterrupt(void) {
    _U1ERIF = 0;
}
