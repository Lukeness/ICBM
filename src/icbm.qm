<?xml version="1.0" encoding="UTF-8"?>
<model version="3.2.2">
 <documentation>Interface to Allegro A4960 BLDC pre-driver</documentation>
 <framework name="qpn"/>
 <package name="AOs" stereotype="0x02">
  <class name="Console" superclass="qpn::QMActive">
   <attribute name="menuselect" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>stores value of selected menu item, if necessary to keep between states</documentation>
   </attribute>
   <attribute name="rpm" type="uint16_t" visibility="0x02" properties="0x00">
    <documentation>motor RPM</documentation>
   </attribute>
   <attribute name="tacho" type="Tacho" visibility="0x00" properties="0x00"/>
   <attribute name="diag" type="uint16_t" visibility="0x00" properties="0x00">
    <documentation>storage for diagnostic output</documentation>
   </attribute>
   <operation name="printStr" type="void" visibility="0x02" properties="0x01">
    <documentation>places pointer to a const string to serial buffer</documentation>
    <parameter name="str" type="const char*"/>
    <code>uint8_t tmphead = consoleHead + 1;

#if CONSOLE_BUFMASK &lt; 255
tmphead &amp;= CONSOLE_BUFMASK;
#endif

while(tmphead == consoleTail) {}     //this line blocks!

consoleBuf[tmphead] = str;
consoleHead = tmphead;

if( _U1TXIE == 0) {    //trigger interrupt
    _U1TXIF = 1;
    _U1TXIE = 1;
}

return;</code>
   </operation>
   <operation name="printNum" type="void" visibility="0x02" properties="0x01">
    <documentation>decimal 'point' from the right</documentation>
    <parameter name="num" type="uint32_t"/>
    <parameter name="base" type="uint8_t"/>
    <parameter name="point" type="uint8_t"/>
    <code>#define CHAR_BUFSIZE 33
const char* const numchars[] = {&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,
    &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;};
const char* buf[CHAR_BUFSIZE];
const char** pStr = &amp;(buf[CHAR_BUFSIZE-1]);

do {
    *(--pStr) = numchars[num % base];
    num /= base;
    } while( num != 0 );

while( pStr &lt; &amp;buf[CHAR_BUFSIZE-1] ) {    //copy the buffer into the queue
    if((&amp;buf[CHAR_BUFSIZE-1] - pStr) == point) {
        Console_printStr(&quot;.&quot;);                       //print decimal point
    }    
    Console_printStr(*pStr++);
}</code>
   </operation>
   <operation name="printWhirlingStar" type="void" visibility="0x02" properties="0x01">
    <code>#define IDX_MASK 3
const char* const rollchar[4] = {&quot;/&quot;,&quot;-&quot;,&quot;\\&quot;,&quot;|&quot;};
static uint8_t idx = 0;

Console_printStr(&quot;\x08&quot;);    //backspace

Console_printStr(rollchar[idx++]);

idx &amp;= IDX_MASK;</code>
   </operation>
   <operation name="printMenuTitle" type="void" visibility="0x02" properties="0x01">
    <parameter name="count" type="uint8_t"/>
    <parameter name="menu" type="const char* const*"/>
    <code>uint8_t i;

Console_printStr(crlf);

for(i = 0; i &lt;= count; i++) {
    Console_printNum(i,10,0U);
    Console_printStr(&quot;. &quot;);
    
    if (i == 0) {
        Console_printStr(&quot;Back&quot;);
    }
    else {
        Console_printStr(menu[i-1]);
    }

    Console_printStr(crlf);
}//for...

Console_printStr(crlf);</code>
   </operation>
   <operation name="printItems" type="void" visibility="0x02" properties="0x00">
    <documentation>Prints set of items defined by array of pointers to access methods</documentation>
    <parameter name="item" type="ITEM**"/>
    <parameter name="cnt" type="uint8_t"/>
    <code>uint8_t i;

Console_printStr(&quot;\r\nPress number to select field,&quot;);
Console_printStr(&quot;\r\nthen w,a,s,d to change it&quot;);
Console_printStr(&quot;\r\n\n0. Back&quot;);

Console_printStr(crlf);

for(i = 0; i &lt; cnt; i++) {
    if(i+1 == me-&gt;menuselect) {    //highlight
        Console_printStr(&quot;&gt;&gt;&gt; &quot;);
    } else {
        Console_printNum(i + 1,10,0U);
        Console_printStr(&quot;. &quot;);
    }

    Console_printStr(item[i]-&gt;name);    //field name

    Console_printStr(&quot; [&quot;);
    Console_printNum(item[i]-&gt;get(&amp;(*item[i])), 2, 0U); //field contents
    Console_printStr(&quot;], &quot;);

    Console_printNum(item[i]-&gt;conv(&amp;(*item[i])), 10, item[i]-&gt;point);//field value
                        
    Console_printStr(space);
    Console_printStr(item[i]-&gt;unit);        //field unit
    Console_printStr(crlf);
}
Console_printStr(crlf);</code>
   </operation>
   <operation name="handleItems" type="void" visibility="0x02" properties="0x00">
    <parameter name="key" type="uint8_t"/>
    <parameter name="item" type="ITEM**"/>
    <parameter name="cnt" type="uint8_t"/>
    <code>uint8_t tmpdata = atoi((const char*)&amp;key);

if(isdigit(key)) {    //numeric
    if(tmpdata &gt; cnt) {
        return;    //wrong key, do not handle
    }
    else {
        me-&gt;menuselect = tmpdata;    //remember selection
        return;
    }
}

if(me-&gt;menuselect == 0) {
    return;    //no further processing necessary
}

tmpdata =
    item[me-&gt;menuselect-1]-&gt;get(&amp;(*item[me-&gt;menuselect-1]));

if(key == 'w' || key == 'W') {    //increment
    tmpdata++;
}

if(key == 's' || key == 'S') { //decrement
    tmpdata--;
}

uint16_t tmplen = item[me-&gt;menuselect-1]-&gt;mask;

while((tmplen &amp; 0x01) == 0 ) { //LSB eq zero
    tmplen &gt;&gt;= 1;
}

tmpdata &amp;= tmplen;
item[me-&gt;menuselect-1]-&gt;set(tmpdata,&amp;(*item[me-&gt;menuselect-1]));</code>
   </operation>
   <operation name="Tacho_ctor" type="void" visibility="0x02" properties="0x01">
    <parameter name="me" type="Tacho* const"/>
    <code>QMsm_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Tacho_initial));</code>
   </operation>
   <operation name="printMenuItems" type="void" visibility="0x02" properties="0x00">
    <documentation>Prints set of items defined by array of pointers to access methods</documentation>
    <parameter name="field" type="FIELD**"/>
    <parameter name="cnt" type="uint8_t"/>
    <code>uint8_t i;

Console_printStr(&quot;\r\nPress number to select field,&quot;
                 &quot;\r\nthen w,a,s,d to change it.&quot;
                 &quot;\r\n\n0. Back&quot;);

//Console_printStr(&quot;\r\nPress number to select field,&quot;);
//Console_printStr(&quot;\r\nthen w,a,s,d to change it&quot;);
//Console_printStr(&quot;\r\n\n0. Back&quot;);

Console_printStr(crlf);

for(i = 0; i &lt; cnt; i++) {
    if(i+1 == me-&gt;menuselect) {    //highlight
        Console_printStr(&quot;&gt;&gt;&gt; &quot;);
    } else {
        Console_printNum(i+1, 10, 0U);
        Console_printStr(&quot;. &quot;);
    }

    Console_printStr(field[i]-&gt;title);    //field name

    Console_printStr(&quot; [&quot;);
    Console_printNum(getField(&amp;(*field[i])), 2, 0U);    //field contents, binary

    Console_printStr(&quot;], &quot;);

    if(field[i]-&gt;conv) {    //conversion needed
        Console_printNum(field[i]-&gt;conv(&amp;(*field[i])),
                         10,
                         field[i]-&gt;point);           //field contents, converted
    } else {
        Console_printNum(getField(&amp;(*field[i])),
                         10,
                         field[i]-&gt;point);             //field contents, decimal
    }
                
    Console_printStr(space);
    Console_printStr(field[i]-&gt;unit);        //field unit
    Console_printStr(crlf);
}
Console_printStr(crlf);</code>
   </operation>
   <operation name="handleMenuItems" type="void" visibility="0x02" properties="0x00">
    <parameter name="key" type="uint8_t"/>
    <parameter name="field" type="FIELD**"/>
    <parameter name="cnt" type="uint8_t"/>
    <code>uint8_t tmpdata = atoi((const char*)&amp;key);

if(isdigit(key)) {    //numeric
    if(tmpdata &gt; cnt) {
        return;    //wrong key, do not handle
    }
    else {
        me-&gt;menuselect = tmpdata;    //remember selection
        return;
    }
}

if(me-&gt;menuselect == 0) {
    return;    //no further processing necessary
}

//tmpdata =
//    item[me-&gt;menuselect-1]-&gt;get(&amp;(*item[me-&gt;menuselect-1]));
tmpdata = getField(&amp;(*field[me-&gt;menuselect-1]));

if(key == 'w' || key == 'W') {    //increment
    tmpdata++;
}

if(key == 's' || key == 'S') {    //decrement
    tmpdata--;
}

uint16_t tmplen = field[me-&gt;menuselect-1]-&gt;mask;

while((tmplen &amp; 0x01) == 0 ) { //LSB eq zero
    tmplen &gt;&gt;= 1;
}

tmpdata &amp;= tmplen;

setField(tmpdata,&amp;(*field[me-&gt;menuselect-1]));
//field[me-&gt;menuselect-1]-&gt;set(tmpdata,&amp;(*item[me-&gt;menuselect-1]));</code>
   </operation>
   <statechart>
    <initial target="../1/9">
     <action>QActive_armX((QActive*)me, 0U, ROLL_TOUT);</action>
     <initial_glyph conn="8,14,4,0,46">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Session">
     <entry>//QActive_armX((QActive*)me, 1U, TACH_TOUT);</entry>
     <tran trig="WCOL">
      <action>Console_printStr(&quot;\r\nA4960 SPI Write collision&quot;);</action>
      <tran_glyph conn="3,79,3,-1,7">
       <action box="0,-2,7,2"/>
      </tran_glyph>
     </tran>
     <tran trig="FF">
      <action>//Fault reported

uint8_t i =
    A4960_TwFlag.get((struct item_t*)&amp;A4960_TwFlag);

me-&gt;diag =
    A4960_TwFlag.set(i, (struct item_t*)&amp;A4960_TwFlag);





Console_printStr(&quot;\r\nA4960 fault&quot;);</action>
      <tran_glyph conn="3,82,3,-1,3">
       <action box="0,-2,4,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TIME_TICK">
      <action brief="dispatch">Q_SIG(&amp;me-&gt;tacho) = Q_SIG(me);
QMSM_DISPATCH((QMsm*)&amp;me-&gt;tacho);</action>
      <tran_glyph conn="3,109,3,-1,19">
       <action box="0,-2,19,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TACHO">
      <action brief="dispatch">Q_SIG((QMsm*)&amp;me-&gt;tacho) = Q_SIG(me);
Q_PAR((QMsm*)&amp;me-&gt;tacho) = Q_PAR(me);
QMSM_DISPATCH((QMsm*)&amp;me-&gt;tacho);
//Console_printStr(&quot;Tacho&quot;);

//QActive_disarmX((QActive*)me, 3U);
//QActive_armX((QActive*)me, 3U, TACH_TOUT);</action>
      <tran_glyph conn="3,107,3,-1,19">
       <action box="0,-2,13,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RPM">
      <action>me-&gt;rpm = Q_PAR(me);</action>
      <tran_glyph conn="3,91,3,-1,4">
       <action box="0,-2,5,2"/>
      </tran_glyph>
     </tran>
     <tran trig="Q_TIMEOUT">
      <action brief="print status line">const char* const diag_flags[] =
    {&quot;FF &quot;,&quot;POR &quot;,&quot;VR &quot;,&quot;?? &quot;,&quot;TW &quot;,&quot;TS &quot;,&quot;LOS &quot;,&quot;VA &quot;,&quot;VB &quot;,
    &quot;VC &quot;,&quot;AH &quot;,&quot;AL &quot;,&quot;BH &quot;,&quot;BL &quot;,&quot;CH &quot;,&quot;CL &quot;};

/* Status line output */
Console_printStr(&quot;\rSpeed: &quot;);
Console_printNum(me-&gt;rpm, 10, 0U);

//run flags
Console_printStr(&quot; [ &quot;);
if(A4960_Run.get((struct item_t*)&amp;A4960_Run)) {    //run flag up
    Console_printStr(&quot;RUN &quot;);
}
if(A4960_Brake.get((struct item_t*)&amp;A4960_Brake)) {    //brake flag up
    Console_printStr(&quot;BRK &quot;);
}
if(A4960_Direction.get((struct item_t*)&amp;A4960_Direction)) {//dir flag up
    Console_printStr(&quot;DIR &quot;);
}
Console_printStr(&quot;]&quot;);

//diagnostic flags
Console_printStr(&quot; [ &quot;);
uint8_t i;
uint16_t tmp = me-&gt;diag;

for(i = 0; i &lt; 16; i++) {
    if(tmp &amp; 0x8000) {    //print flag if set
        Console_printStr(diag_flags[i]);
    }
    tmp &lt;&lt;=1;
}
Console_printStr(&quot;]&quot;);


Console_printStr(&quot;   &quot;);
QActive_armX(&amp;me-&gt;super, 0U, STAT_TOUT);</action>
      <tran_glyph conn="3,76,3,-1,19">
       <action box="0,-2,20,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RBUT_PRESS">
      <action>Console_printStr(&quot;\r\n\r\nRun Button Pressed\r\n&quot;);

A4960_Run.set(1, (struct item_t*)&amp;A4960_Run);

//A4960_Run-&gt;name

//Console_printStr(A4960_Run.name);</action>
      <tran_glyph conn="3,85,3,-1,9">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RBUT_RELEASE">
      <action>Console_printStr(&quot;\r\n\r\nRun Button Released\r\n&quot;);</action>
      <tran_glyph conn="3,88,3,-1,11">
       <action box="0,-2,11,2"/>
      </tran_glyph>
     </tran>
     <state name="Main">
      <entry>Console_printStr(&quot;\r\nMain Menu: &quot;);
Console_printMenuTitle(MENU_MAIN_CNT, menuMain);</entry>
      <exit>me-&gt;menuselect = 0;    //reset menu selection</exit>
      <tran trig="KBD_KEY">
       <action>//Console_printStr(me,&quot;\r\nKey Pressed&quot;);

//U1TXREG = Q_PAR(me);

//U1TXREG = 'A';</action>
       <choice target="../../../10">
        <guard brief="1">(uint8_t)(Q_PAR(me)) == '1'</guard>
        <choice_glyph conn="29,32,5,3,31">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../11">
        <guard brief="2">(uint8_t)(Q_PAR(me)) == '2'</guard>
        <choice_glyph conn="29,32,4,3,10,4">
         <action box="0,7,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../12">
        <guard brief="3">(uint8_t)(Q_PAR(me)) == '3'</guard>
        <choice_glyph conn="29,32,4,3,28,3">
         <action box="1,18,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="12,32,5,-1,17">
        <action box="0,-2,9,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="12,25,13,12">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="Idle">
      <entry>//Console_printStr(&quot;\r\nPress any key to enter console..  &quot;);
//QActive_armX((QActive*)me, 1U, TACHO_TOUT);</entry>
      <exit>//QActive_disarmX(&amp;me-&gt;super, 0U);</exit>
      <tran trig="Q_TIMEOUT">
       <action>QActive_armX(&amp;me-&gt;super, 0U, ROLL_TOUT);
Console_printWhirlingStar();</action>
       <tran_glyph conn="6,66,3,-1,8">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="KBD_KEY" target="../../8">
       <action>Console_printStr(&quot;\r\nInteractive Controller for Brushless Motors Console rev.&quot;);
Console_printStr(REV);
Console_printStr(&quot;\r\nCompiled on &quot;);
Console_printStr(__DATE__);
Console_printStr(&quot; at &quot;);
Console_printStr(__TIME__);
Console_printStr(&quot; using Microchip XC16 C compiler ver.&quot;);
Console_printNum(__XC16_VERSION__, 10,0U);
Console_printStr(&quot;\r\n\n&quot;);</action>
       <tran_glyph conn="6,69,3,2,11,-32">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="6,60,16,11">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="Setup">
      <entry>Console_printStr(&quot;\r\nSetup Menu:&quot;);
Console_printMenuTitle(MENU_SETUP_CNT, menuSetup);</entry>
      <tran trig="KBD_KEY">
       <action>Console_printStr(&quot;\r\n&quot;);</action>
       <choice target="../..">
        <guard>else</guard>
        <choice_glyph conn="72,37,5,2,-8,-3">
         <action box="-6,-2,6,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../8">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="72,37,4,0,-14,-50,2">
         <action box="-4,-16,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../18">
        <guard brief="1">(uint8_t)(Q_PAR(me)) == '1'</guard>
        <choice_glyph conn="72,37,5,3,8">
         <action box="1,-2,10,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../19">
        <guard brief="2">(uint8_t)(Q_PAR(me)) == '2'</guard>
        <choice_glyph conn="72,37,4,3,12,8">
         <action box="0,10,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="60,32,3,-1,12,5">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="60,25,8,9">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Mess">
      <entry>Console_printStr(&quot;\r\nMess Menu:&quot;);
Console_printMenuTitle(MENU_MESS_CNT, menuMess);</entry>
      <exit>me-&gt;menuselect = 0;    //reset menu selection</exit>
      <tran trig="KBD_KEY">
       <action>Console_printStr(&quot;\r\n&quot;);</action>
       <choice target="../../../13">
        <guard brief="1">(uint8_t)(Q_PAR(me)) == '1'</guard>
        <choice_glyph conn="42,47,5,3,8">
         <action box="1,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../14">
        <guard brief="2">(uint8_t)(Q_PAR(me)) == '2'</guard>
        <choice_glyph conn="42,47,4,3,10,8">
         <action box="1,8,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../15">
        <guard brief="3">(uint8_t)(Q_PAR(me)) == '3'</guard>
        <choice_glyph conn="42,47,4,3,22,8">
         <action box="1,20,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../17">
        <guard brief="4">(uint8_t)(Q_PAR(me)) == '4'</guard>
        <choice_glyph conn="42,47,4,3,34,8">
         <action box="1,32,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../16">
        <guard brief="5">(uint8_t)(Q_PAR(me)) == '5'</guard>
        <choice_glyph conn="42,47,4,3,46,8">
         <action box="1,44,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../8">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="42,47,5,2,-20,-10">
         <action box="-10,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <choice_glyph conn="42,47,5,2,-7,-3">
         <action box="-6,-2,6,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="33,42,3,-1,9,5">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="33,34,8,10">
       <entry box="1,2,4,2"/>
       <exit box="1,4,4,2"/>
      </state_glyph>
     </state>
     <state name="Tune">
      <entry>Console_printStr(&quot;\r\nTune Menu:&quot;);
Console_printMenuTitle(MENU_TUNE_CNT, menuTune);</entry>
      <state_glyph node="32,54,9,9">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Limits">
      <documentation>Manipulating BLDC controller limits</documentation>
      <entry>//Console_printItems(me, (ITEM**)limitsItems, LIMITS_CNT);
Console_printMenuItems(me, (FIELD**)limitsFields, LIMITS_COUNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../11">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="58,47,5,1,5,-9,-22">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>//Console_handleItems
//    (me,(uint8_t)Q_PAR(me),(ITEM**)limitsItems, LIMITS_CNT);

Console_handleMenuItems
    (me,(uint8_t)Q_PAR(me),(FIELD**)limitsFields, LIMITS_CNT);</action>
        <choice_glyph conn="58,47,4,3,-3,-8">
         <action box="-4,-5,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="50,47,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="50,39,10,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Run">
      <documentation>Manipulating run parameters</documentation>
      <entry>Console_printItems(me, (ITEM**)runItems, RUN_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../11">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="58,57,5,1,5,-19,-22">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>Console_handleItems
    (me, (uint8_t)Q_PAR(me), (ITEM**)runItems, RUN_CNT);</action>
        <choice_glyph conn="58,57,4,3,3,-8">
         <action box="-6,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="50,57,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="50,51,10,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Startup">
      <entry>Console_printItems
    (me, (ITEM**)startupItems, STARTUP_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../11">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="58,69,5,1,5,-31,-22">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>Console_handleItems
    (me, (uint8_t)Q_PAR(me), (ITEM**)startupItems,
    STARTUP_CNT);</action>
        <choice_glyph conn="58,69,4,3,3,-8">
         <action box="-6,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="50,69,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="50,63,10,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Misc">
      <entry>Console_printItems
    (me, (ITEM**)miscItems, MISC_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../11">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="58,93,5,1,5,-55,-22">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>Console_handleItems
    (me, (uint8_t)Q_PAR(me), (ITEM**)miscItems,
    MISC_CNT);</action>
        <choice_glyph conn="58,93,4,3,3,-8">
         <action box="-6,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="50,93,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="50,87,10,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Flags">
      <entry>Console_printStr(&quot;\r\nUse 'Misc' menu for non-bridge related faults&quot;);

Console_printItems
    (me, (ITEM**)flagsItems, FLAGS_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../11">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="58,81,5,1,5,-43,-22">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>Console_handleItems
    (me, (uint8_t)Q_PAR(me), (ITEM**)flagsItems,
    MISC_CNT);</action>
        <choice_glyph conn="58,81,4,3,3,-8">
         <action box="-6,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="50,81,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="50,75,10,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Control">
      <entry>Console_printItems(me, (ITEM**)controlItems, CONTROL_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../10">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="88,37,5,1,8,-8,-28">
         <action box="4,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>Console_handleItems
    (me,(uint8_t)Q_PAR(me),(ITEM**)controlItems, CONTROL_CNT);</action>
        <choice_glyph conn="88,37,4,3,3,-8">
         <action box="-5,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="80,37,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="80,31,11,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="UI">
      <entry>Console_printItems(me, (ITEM**)uiItems, UI_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../10">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="87,49,5,1,9,-20,-28">
         <action box="5,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>Console_handleItems
    (me,(uint8_t)Q_PAR(me),(ITEM**)uiItems, UI_CNT);</action>
        <choice_glyph conn="87,49,4,3,3,-7">
         <action box="-5,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="80,49,3,-1,7">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="80,43,11,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,17,96,95">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="167,145"/>
   </statechart>
  </class>
  <class name="Tacho" superclass="qpn::QMsm">
   <documentation>Tachometer output handler. Timeouts if no tachometer event has happened
in 0.5 sec., otherwise collects and processes tach data.</documentation>
   <attribute name="cnt" type="uint8_t" visibility="0x02" properties="0x00"/>
   <statechart>
    <initial target="../1">
     <initial_glyph conn="18,8,5,0,12,2">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Idle">
     <entry>QACTIVE_POST_X((QActive*)&amp;AO_Console, 1, RPM_SIG, 0U);    //send out zero RPM</entry>
     <tran trig="TACHO" target="../../2">
      <action>//Console_printStr(&quot;Tacho start&quot;);</action>
      <tran_glyph conn="16,19,3,1,19,10,-2">
       <action box="0,-2,5,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TIME_TICK">
      <tran_glyph conn="16,16,3,-1,13">
       <action box="0,-2,13,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="16,10,17,11">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state name="Process">
     <tran trig="TIME_TICK">
      <choice target="../../../1">
       <guard brief=" ">me-&gt;cnt-- == 0</guard>
       <choice_glyph conn="23,33,5,3,-11,-17,4">
        <action box="-4,-2,4,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="33,33,1,-1,-10">
       <action box="-8,-2,13,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TACHO">
      <action>static uint32_t tachoLPS = 0U; /* Low-Pass-Filtered tacho reading */

me-&gt;cnt = 1;

uint32_t tmp = Q_PAR(me);    //get tacho reading

/* 1st order low-pass filter: time constant ~= 2^n samples
* TF = (1/2^n)/(z-((2^n - 1)/2^n)),
* eg, n=3, y(k+1) = y(k) - y(k)/8 + x(k)/8 =&gt; y += (x - y)/8
* - borrowed from M.Samek */
tachoLPS += (((int)tmp - (int)tachoLPS + 4) &gt;&gt; 8);       /* Low-Pass-Filter */

QACTIVE_POST_X((QActive*)&amp;AO_Console, 1, RPM_SIG,
    tachoLPS);    //send out RPM</action>
      <tran_glyph conn="33,29,1,-1,-8">
       <action box="-6,-2,6,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="16,23,17,12"/>
    </state>
    <state_diagram size="50,48"/>
   </statechart>
  </class>
  <attribute name="AO_Console" type="struct Console" visibility="0x00" properties="0x00"/>
  <operation name="Console_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Console *me = &amp;AO_Console;
QMActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Console_initial));
//me-&gt;tacho = &amp;l_tacho;
Console_Tacho_ctor(&amp;me-&gt;tacho);
QMSM_INIT((QMsm*)&amp;me-&gt;tacho);

/* Initialize console hardware */

       U1MODE = 0x0008;                                /* enable high baud rate */
       U1STAbits.UTXISEL1 = 1;
       U1BRG  = ((FCY / 4 / BAUD_RATE_CONSOLE) - 1);    /* baud rate generator */

       _U1TXIP = 1; //serial interrupt priority
       _U1RXIP = 1;
       _U1ERIP = 1;
       U1MODEbits.UARTEN = 1;    //UART then Tx - in that order!
       U1STAbits.UTXEN   = 1;

{    uint8_t tmpdata;
       tmpdata = U1RXREG;       //clear RX errors
}
       U1STAbits.FERR = 0;
       U1STAbits.OERR = 0;

       CONSOLE_RX_TRIS = 1;    //set RX to input. todo - make less hardcoded

       consoleTail = 0;
       consoleHead = 0;

        //do not enable interrupts here - do it in QF_onStartup()
        _U1RXIF = 0;
        _U1ERIF = 0;
        </code>
  </operation>
 </package>
 <package name="BSP" stereotype="0x02">
  <package name="ISR" stereotype="0x02">
   <operation name="_AddressError" type="void __attribute__((__interrupt__,__no_auto_psv__))" visibility="0x00" properties="0x00">
    <code>while(1);    //Address error</code>
   </operation>
   <operation name="_StackError" type="void __attribute__((__interrupt__,__no_auto_psv__))" visibility="0x00" properties="0x00">
    <code>while(1);</code>
   </operation>
   <operation name="_T1Interrupt" type="void __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <documentation>QPN Tick generator</documentation>
    <code>//typedef struct but_t {    //button debouncing 


static uint32_t btn_debounced  = 0U;
static uint8_t  debounce_state = 0U;

//static uint32_t rbut_debounced  = 0U;
//static uint8_t  rbut_debounce_state = 0U;

//static uint32_t bbut_debounced  = 0U;
//static uint8_t  bbut_debounce_state = 0U;

uint8_t btn = RBUT_PIN;          /* read the push button state */
    switch (debounce_state) {
        case 0:
            if (btn != btn_debounced) {
                debounce_state = 1;         /* transition to the next state */
            }
            break;
        case 1:
            if (btn != btn_debounced) {
                debounce_state = 2;         /* transition to the next state */
            }
            else {
                debounce_state = 0;           /* transition back to state 0 */
            }
            break;
        case 2:
            if (btn != btn_debounced) {
                debounce_state = 3;         /* transition to the next state */
            }
            else {
                debounce_state = 0;           /* transition back to state 0 */
            }
            break;
        case 3:
            if (btn != btn_debounced) {
                btn_debounced = btn;     /* save the debounced button value */

                if (btn == 0) {                 /* is the button depressed? */
                    QACTIVE_POST_X_ISR((QActive *)&amp;AO_Console, 1,
                        RBUT_PRESS_SIG, 0);
                }
                else {
                    QACTIVE_POST_X_ISR((QActive *)&amp;AO_Console, 1,
                        RBUT_RELEASE_SIG, 0);
                }

            }
            debounce_state = 0;               /* transition back to state 0 */
            break;
    }

_T1IF = 0;                              /* clear Timer 1 interrupt flag */

QACTIVE_POST_X_ISR((QActive*)&amp;AO_Console, 1,
    TIME_TICK_SIG, 0U);

QF_tickISR();                /* handle all armed time events in QF-nano */</code>
   </operation>
   <operation name="_U1RXInterrupt" type="void  __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <code>uint8_t tmpdata;
while( U1STAbits.URXDA == 1 ) {      
    tmpdata = U1RXREG;            
    QACTIVE_POST_X_ISR
        ((QActive*)&amp;AO_Console, 1, KBD_KEY_SIG, tmpdata);
}
_U1RXIF = 0;
//Input can be paced by disabling interrupt here
// and re-enabling in &amp;Console</code>
   </operation>
   <operation name="_U1TXInterrupt" type="void  __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <documentation>UART1 transmit ISR</documentation>
    <code>static const char* pPrintStr = 0; //stores a string being printed

while( U1STAbits.UTXBF == 0 ) {    //UART buffer available
    if( *pPrintStr ) {             //previous string not completed
        U1TXREG = *pPrintStr++;
    }//if( *pPrintStr...
    else {                         //get next string
        if( consoleHead != consoleTail ) {    //data available
            consoleTail++;
#if CONSOLE_BUFMASK &lt; 255
            consoleTail &amp;= CONSOLE_BUFMASK;
#endif //CONSOLE_TX_BUFMASK &lt; 255

             pPrintStr = consoleBuf[consoleTail];
        }
        else {              //queue empty
            _U1TXIE = 0;    //disable interrupt
            return;    //IF not cleared - bug?
         }
    }//else - get next string
}//while( U2STAbits.UTXBF == 0...

_U1TXIF = 0;    //clear interrupt</code>
   </operation>
   <operation name="_U1ErrInterrupt" type="void  __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <code>_U1ERIF = 0;</code>
   </operation>
  </package>
  <package name="QPn" stereotype="0x02">
   <operation name="QF_onStartup" type="void" visibility="0x00" properties="0x00">
    <code>T1CON = 0x0000U;  /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1 */
TMR1  = 0x0000U; /* Start counting from 0 and clear the prescaler count */
PR1   = (uint16_t)((FCY_HZ / BSP_TICKS_PER_SEC) - 1.0 + 0.5); /* period */
_T1IP = TIMER1_ISR_PRIO;              /* set Timer 2 interrupt priority */
_T1IF = 0;                           /* clear the interrupt for Timer 1 */
_T1IE = 1;                              /* enable interrupt for Timer 1 */
T1CONbits.TON = 1;                                     /* start Timer 1 */

/* Enable peripheral interrupts as late as possible */
_CCT2IE = 1;    //tacho timer
_CCP2IE = 1;    //tacho capture
_U1RXIE = 1;                                     /* Console on UART1 Rx */
_NVMIE = 1;            //EEPROM</code>
   </operation>
   <operation name="QF_onIdle" type="void" visibility="0x00" properties="0x00">
    <documentation>/*****************************************************************************
* NOTE01:
* The callback function QF_onIdle() is called with interrupts disabled,
* because the idle condition can be invalidated by any enabled interrupt
* that would post events. The QF_onIdle() function *must* enable interrupts
* internally
*
* NOTE02:
* To be on the safe side, the DISICNT counter is set to just 1 cycle just
* before entering the Idle mode (or Sleep mode, if you choose). This way,
* interrupts (with priorities 1-6) get enabled at the same time as the
* transition to the low-power mode.
*/</documentation>
    <code>//LED_ON ();
//LED_OFF();

#ifdef NDEBUG
    __asm__ volatile(&quot;disi #0x0001&quot;);
    Idle();                          /* transition to Idle mode, see NOTE02 */
#else
    QF_INT_ENABLE();                       /* enable interrupts, see NOTE01 */
#endif</code>
   </operation>
   <operation name="Q_onAssert" type="void" visibility="0x00" properties="0x00">
    <parameter name="file" type="char const Q_ROM * const Q_ROM_VAR"/>
    <parameter name="line" type="int"/>
    <code>(void)file;                                   /* avoid compiler warning */
(void)line;                                   /* avoid compiler warning */
QF_INT_DISABLE();             /* make sure that interrupts are disabled */
for (;;) {
}</code>
   </operation>
  </package>
  <package name="A4960" stereotype="0x02">
   <package name="Common" stereotype="0x02">
    <operation name="SPI_init" type="void" visibility="0x02" properties="0x00">
     <documentation>mode 0: CKP = 0; CKE = 1;</documentation>
     <code>SSP2STATbits.CKE = 1;
SSP2CON1bits.SSPM = 0b1010;
SSP2ADD = 0x0f;    //1 MHz SPI clock
SSP2CON1bits.SSPEN = 1; //enable SPI
MISO_TRIS = 1;    //set MISO line to input</code>
    </operation>
    <operation name="A4960_xfer" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>read/write A4960 config register. May utilize PIC MSSP-specific double-buffering</documentation>
     <parameter name="reg" type="uint8_t"/>
     <parameter name="data" type="uint16_t"/>
     <code>A4960_CS_PIN = 0;

uint16_t tmpdata;

SSP2BUF = ((reg &lt;&lt; 4) | (data &gt;&gt; 8));    //send upper byte
while(SSP2STATbits.BF == 0);    //wait till end of xfer

tmpdata = SSP2BUF;

if(tmpdata &amp; 0x80) {    //A4960 fault
    QACTIVE_POST_X((QActive*)&amp;AO_Console, 1, FF_SIG,0U);
};

SSP2BUF = data &amp; 0xff;        //send lower byte

tmpdata = tmpdata &lt;&lt; 8;
while(SSP2STATbits.BF == 0);    //wait till end of xfer

tmpdata = (tmpdata | SSP2BUF);

A4960_CS_PIN = 1;

/* Look out for events */

if(SSP2CON1bits.WCOL == 1) {    //write collision
    SSP2CON1bits.WCOL = 0;        //clear
    QACTIVE_POST_X((QActive*)&amp;AO_Console, 1, WCOL_SIG,0U);
}

return tmpdata;</code>
    </operation>
    <operation name="A4960_getField" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>get contents of a 'reg' and extracts field defined by 'mask'</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>uint16_t tmpdata = A4960_xfer(item-&gt;reg,0U);
uint16_t tmpmask = item-&gt;mask;

tmpdata &amp;= tmpmask;    //clear the rest

while((tmpmask &amp; 0x01) == 0) {    //LSB equals 0
    tmpmask &gt;&gt;= 1;
    tmpdata &gt;&gt;= 1;
};

return(tmpdata);</code>
    </operation>
    <operation name="A4960_setField" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>'val' sets content of the field defined by 'reg', 'mask'</documentation>
     <parameter name="val" type="uint16_t"/>
     <parameter name="item" type="ITEM*"/>
     <code>uint16_t tmpdata = A4960_xfer(item-&gt;reg,0U);
uint16_t tmpmask = item-&gt;mask;
uint16_t tmpval = val;

tmpdata &amp;= ~tmpmask; //clear the field position

while((tmpmask &amp; 0x1) == 0) { //LSB equals 0
    tmpmask &gt;&gt;= 1;
    tmpval &lt;&lt;= 1;
}

tmpdata |= tmpval;            //insert field

return(A4960_xfer(item-&gt;reg + 1, tmpdata));//write</code>
    </operation>
    <operation name="A4960_convPercent" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>converts contents to percent (x6.25)</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>return((A4960_getField(item) + 1)*625U);</code>
    </operation>
    <operation name="getField" type="uint16_t" visibility="0x00" properties="0x00">
     <documentation>get contents of a 'reg' and extracts field defined by 'mask'</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>uint16_t tmpdata = A4960_xfer(field-&gt;reg,0U);
uint16_t tmpmask = field-&gt;mask;

tmpdata &amp;= tmpmask;    //clear the rest

while((tmpmask &amp; 0x01) == 0) {    //LSB equals 0
    tmpmask &gt;&gt;= 1;
    tmpdata &gt;&gt;= 1;
};

return(tmpdata);</code>
    </operation>
    <operation name="setField" type="uint16_t" visibility="0x00" properties="0x00">
     <documentation>'val' sets content of the field defined by 'reg', 'mask'</documentation>
     <parameter name="val" type="uint16_t"/>
     <parameter name="field" type="FIELD*"/>
     <code>uint16_t tmpdata = A4960_xfer(field-&gt;reg,0U);
uint16_t tmpmask = field-&gt;mask;
uint16_t tmpval = val;

tmpdata &amp;= ~tmpmask; //clear the field position

while((tmpmask &amp; 0x1) == 0) { //LSB equals 0
    tmpmask &gt;&gt;= 1;
    tmpval &lt;&lt;= 1;
}

tmpdata |= tmpval;            //insert field

return(A4960_xfer(field-&gt;reg + 1, tmpdata));//write</code>
    </operation>
   </package>
   <package name="Limits" stereotype="0x02">
    <operation name="A4960_ConvCommBlankTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>Communication Blank Time converter</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>const uint16_t const blanktimes[] = {50U,100U,400U,1000U};

uint8_t tmpdata = A4960_getField(item);

return(blanktimes[tmpdata]);</code>
    </operation>
    <operation name="A4960_ConvBlankTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Blank Time</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>return(400U*A4960_getField(item));</code>
    </operation>
    <operation name="A4960_ConvDeadTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Config 0 DT field AKA Dead Time. DS p.26</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>uint16_t tmpdata = A4960_getField(item);

return((tmpdata &lt; 3) ? 100U : tmpdata*50U);</code>
    </operation>
    <operation name="A4960_ConvVdsThreshold" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Vds Threshold</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>return(25U*A4960_getField(item));</code>
    </operation>
    <operation name="ConvCommBlankTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>Communication Blank Time converter</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>const uint16_t const blanktimes[] = {50U,100U,400U,1000U};

uint8_t tmpdata = getField(field);

return(blanktimes[tmpdata]);</code>
    </operation>
   </package>
   <package name="Run" stereotype="0x02">
    <operation name="A4960_ConvFixedOffTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Commutation Blank Time,DS p.27</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>return(10+(A4960_getField(item)*16U));</code>
    </operation>
    <operation name="A4960_ConvPhaseAdvance" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Phase Advance, x1000</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>return(A4960_getField(item)*1875U); //deg(e), DS p.28</code>
    </operation>
    <operation name="A4960_ConvBemfWindow" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of BEMF Window, x10</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>return(0x04 &lt;&lt; A4960_getField(item)); //us DS p.29</code>
    </operation>
   </package>
   <package name="Startup" stereotype="0x02">
    <operation name="A4960_ConvHoldTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Hold Time</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>return(A4960_getField(item)*8 + 2); //ms DS p.27</code>
    </operation>
    <operation name="A4960_ConvEndCommTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of End Commutation Time. 10x scale</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>return((A4960_getField(item) + 1)*2U); //ms, DS p.28</code>
    </operation>
    <operation name="A4960_ConvStartCommTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Start Commutation Time.</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>return((A4960_getField(item) + 1)*8U); //ms, DS p.28</code>
    </operation>
    <operation name="A4960_ConvRampRate" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Ramp Rate, x1000</documentation>
     <parameter name="item" type="ITEM*"/>
     <code>return((A4960_getField(item) + 1)*2U); //ms, DS p.28</code>
    </operation>
   </package>
  </package>
  <package name="PWM" stereotype="0x02">
   <operation name="PWM_init" type="void" visibility="0x02" properties="0x00">
    <code>CCP1CON1Lbits.CCSEL = 0;    //mode
CCP1CON1Lbits.MOD = 0b0101;

CCP1CON1Lbits.TMR32 = 0;    //timebase
CCP1CON1Lbits.TMRSYNC = 0;
CCP1CON1Lbits.CLKSEL = 0b000;
CCP1CON1Lbits.TMRPS = 0b00;
CCP1CON1Hbits.TRIGEN = 0;
CCP1CON1Hbits.SYNC = 0b00000;

CCP1CON2Hbits.OCBEN = 1;    //enable PWM on the output
CCP1CON3Hbits.OUTM = 0b000;
CCP1CON3Hbits.POLBDF = 0;    //active high
CCP1TMRL = 0x0000;
CCP1PRL = 3200U;
CCP1RA = 0x000;
CCP1RB = 0x001ff;
CCP1CON1Lbits.CCPON = 1;</code>
   </operation>
   <operation name="PWM_idxLookup" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>returns index of array element containing 'val'. 8 element array 
hardcoded</documentation>
    <parameter name="array" type="const uint16_t*"/>
    <parameter name="val" type="uint16_t"/>
    <code>uint8_t i = 0;

while( i &lt; 8 ) {
    if(array[i] == val) {
        return(i);
    }
    i++;
}

return(0xff); //not found</code>
   </operation>
   <operation name="PWM_getPeriodIdx" type="uint16_t" visibility="0x02" properties="0x00">
    <documentation>dummy parameter to conform to a funcptr.</documentation>
    <parameter name="item" type="ITEM*"/>
    <code>return(PWM_idxLookup(pwmPeriod,CCP1PRL));</code>
   </operation>
   <operation name="PWM_setPeriod" type="uint16_t" visibility="0x02" properties="0x00">
    <parameter name="val" type="uint16_t"/>
    <parameter name="item" type="ITEM*"/>
    <code>return(CCP1PRL = pwmPeriod[val]);</code>
   </operation>
   <operation name="PWM_getDuty" type="uint16_t" visibility="0x02" properties="0x00">
    <parameter name="item" type="ITEM*"/>
    <code>return(0);</code>
   </operation>
   <operation name="PWM_setDuty" type="uint16_t" visibility="0x02" properties="0x00">
    <parameter name="val" type="uint16_t"/>
    <parameter name="item" type="ITEM*"/>
    <code>return(0);</code>
   </operation>
   <operation name="PWM_convFreq" type="uint16_t" visibility="0x02" properties="0x00">
    <documentation>returns interger of a frequency. Hardcoded</documentation>
    <parameter name="item" type="ITEM*"/>
    <code>return(pwmFreq[PWM_getPeriodIdx(item)]);</code>
   </operation>
  </package>
  <package name="Tacho" stereotype="0x02">
   <operation name="Tacho_init" type="void" visibility="0x02" properties="0x00">
    <documentation>IC2 on tacho</documentation>
    <code>CCP2CON1Lbits.CCPON = 0;   //disable
CCP2CON1Lbits.CCSEL = 1;   //input capture mode
CCP2CON1Lbits.CLKSEL = 0;  //sysclk
CCP2CON1Lbits.TMR32 = 0;   //32-bit mode
CCP2CON1Lbits.MOD = 1;     //rising every rising edge
CCP2CON2Hbits.ICSEL = 0;   //rising edge
CCP1CON1Hbits.IOPS = 0;    //interrupt on every event
CCP1CON1Lbits.TMRPS = 0;   //prescaler
CCP2CON1Lbits.CCPON = 1;   //enable

_CCT2IP = 1;    //tacho timer interrupt priority
                //must be lower than tacho capture
_CCP2IP = 6;    //tacho capture interrupt priority</code>
   </operation>
   <operation name="_CCT2Interrupt" type="void __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <documentation>Tachometer timer overflow interrupt </documentation>
    <code>tach_ro++;
_CCT2IF = 0;</code>
   </operation>
   <operation name="_CCP2Interrupt" type="void __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <documentation>measuring TACHO output from A4960</documentation>
    <code>static uint16_t oldval = 0;
uint16_t tmpdata = 0;
uint16_t tmp2 = 0;

while(CCP2STATLbits.ICBNE) {    //data present
    tmpdata = CCP2BUFL;
}

tmp2 = tmpdata;
tmpdata += oldval;
oldval = ~tmp2;

//tmpdata |= (uint32_t)tach_ro &lt;&lt; 16;

QACTIVE_POST_X_ISR ((QActive*)&amp;AO_Console, 1,
TACHO_SIG, tmpdata);

//tach_ro = 0;

_CCP2IF = 0;</code>
   </operation>
  </package>
  <package name="HEE" stereotype="0x00">
   <operation name="_NVMInterrupt" type="void __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <documentation>Interrupt on end of EEPROM modification operation</documentation>
    <code>if( heeq_Head != heeq_Tail ) {    //data available
            heeq_Tail++;
#if HEEQ_BUFMASK &lt; 255
            heeq_Tail &amp;= HEEQ_BUFMASK;
#endif

// __ builtin_software_breakpoint();

    HEE_REQ req = heeq[heeq_Tail];

//_prog_addressT p = req.addr;

    NVMCONbits.NVMOP = req.addr;
//    TBLPAG = __builtin_tblpage(p);
//    uint16_t offset = __builtin_tbloffset(&amp;p);

    if(req.op == EE_WRITE) {
        // Write Data Value To Holding Latch
//        __builtin_tblwtl(offset, req.data);
    }
    else {
//        __builtin_tblwtl(offset, offset);
    }
    // Disable Interrupts For 5 Instructions
    asm volatile (&quot;disi #5&quot;);
    // Issue Unlock Sequence &amp; Start Write Cycle
    __builtin_write_NVM();
}
else { //queue empty
    _NVMIE = 0;
}

_NVMIF = 0;</code>
   </operation>
   <operation name="HEE_init" type="void" visibility="0x02" properties="0x00">
    <code>NVMCONbits.PGMONLY = 1;
_NVMIP = 1;    //priority</code>
   </operation>
   <operation name="HEE_send" type="void" visibility="0x02" properties="0x00">
    <documentation>places EE request into request queue.</documentation>
    <parameter name="addr" type="_prog_addressT"/>
    <parameter name="op" type="uint8_t"/>
    <parameter name="data" type="uint16_t"/>
    <code>HEE_REQ req;

req-&gt;addr = addr;
req-&gt;op = op;
req-&gt;data = data;

uint8_t tmphead = heeq_Head + 1;

#if HEEQ_BUFMASK &lt; 255
tmphead &amp;= HEEQ_BUFMASK;
#endif

while(tmphead == heeq_Tail) {}     //this line blocks!

heeq[tmphead] = req;
heeq_Head = tmphead;

if(_NVMIE == 0) {    //trigger interrupt
    _NVMIF = 1;
    _NVMIE = 1;
}

return;</code>
   </operation>
   <operation name="EEwr" type="_prog_addressT" visibility="0x00" properties="0x00">
    <documentation>writes one EE variable. Returns EEDATA address where var is actually written.</documentation>
    <parameter name="id" type="uint8_t"/>
    <parameter name="val" type="uint8_t"/>
    <code>uint8_t i;

if(id &gt;= HEE_PAGESIZE ) {    //range check
    return(0);
}

/* get current page */

for(i = 0; i &lt; HEE_PAGES &amp;&amp; (heep[i][0] &amp; 0x8000); i++ ) {}

if(i == HEE_PAGES) {    //no current page
    while(1);    //todo: handle
}
else {    //find first vacant location
    </code>
   </operation>
  </package>
  <operation name="BSP_init" type="void" visibility="0x00" properties="0x00">
   <code>RCONbits.SWDTEN = 0;                                /* disable Watchdog */

TRISA = 0x00;                                /* set LED pins as outputs */
PORTA = 0x00;                               /* set LEDs drive state low */
TRISB = 0x00;
PORTB = 0x00;
ANSA = 0x00;
ANSB = 0x00;

TACHO_TRIS = 1;    //tachometer input
DIAG_TRIS = 1;     //diag pin input
RBUT_TRIS = 1;    //RUN button
BBUT_TRIS = 1;    //BRAKE button



SPI_init();
PWM_init();
Tacho_init();
HEE_init();</code>
  </operation>
 </package>
 <directory name=".">
  <file name="bsp.h">
   <text>#ifndef bsp_h
#define bsp_h

#include &lt;xc.h&gt;

#define FOSC_HZ                 32000000.0    /* clock */
                                       /* instruction cycle clock frequency */
#define FCY_HZ                  (FOSC_HZ / 2.0)

#define FCY FCY_HZ

                                               /* the system tick rate [Hz] */
#define BSP_TICKS_PER_SEC    100UL


/* A4960 constants */

#define A4960_CONF0_RD 0
#define A4960_CONF0_WR 1
#define A4960_CONF1_RD 2
#define A4960_CONF1_WR 3
#define A4960_CONF2_RD 4
#define A4960_CONF2_WR 5
#define A4960_CONF3_RD 6
#define A4960_CONF3_WR 7
#define A4960_CONF4_RD 8
#define A4960_CONF4_WR 9
#define A4960_CONF5_RD 0x0a
#define A4960_CONF5_WR 0x0b
#define A4960_MASK_RD 0x0c
#define A4960_MASK_WR 0x0d  
#define A4960_RUN_RD 0x0e
#define A4960_RUN_WR 0x0f

#ifdef UNDEF

typedef struct __attribute__((__packed__)) tagConfig0 {
    union {
        uint16_t val;
        struct {
            unsigned dt:6;
            unsigned bt:4;
            unsigned cb:2;            
            unsigned reg:4;            
        };
    };
} A4960_CONFIG0;
        
typedef struct __attribute__((__packed__)) tagConfig1 {
    union {
        uint16_t val;
        struct {
            unsigned vt:6;
            unsigned vr:4;
            unsigned :2;
            unsigned reg:4;
        };
    };
} A4960_CONFIG1;

typedef struct __attribute__((__packed__)) tagConfig2 {
    union {
        uint16_t val;
        struct {
            unsigned pt:5;
            unsigned :7;
            unsigned reg:4;
        };
    };
} A4960_CONFIG2;

typedef struct __attribute__((__packed__)) tagConfig3 {
    union {
        uint16_t val;
        struct {
            unsigned ht:4;
            unsigned hq:4;
            unsigned ids:1;
            unsigned :3;
            unsigned reg:4;
        };
    };
} A4960_CONFIG3;

typedef struct __attribute__((__packed__)) tagConfig4 {
    union {
        uint16_t val;
        struct {
            unsigned sc:4;
            unsigned ec:4;
            unsigned :4;
            unsigned reg:4;
        };
    };
} A4960_CONFIG4;

typedef struct __attribute__((__packed__)) tagConfig5 {
    union {
        uint16_t val;
        struct {
            unsigned rr:4;
            unsigned rq:4;
            unsigned pa:4;
            unsigned reg:4;
        };
    };
} A4960_CONFIG5;

typedef struct __attribute__((__packed__)) tagMask {
    union {
        uint16_t val;
        struct {
            unsigned cl:1;
            unsigned ch:1;
            unsigned bl:1;
            unsigned bh:1;
            unsigned al:1;
            unsigned ah:1;
            unsigned vc:1;
            unsigned vb:1;
            unsigned va:1;
            unsigned los:1;
            unsigned ts:1;
            unsigned tw:1;
            unsigned reg:4;
        };
    };
} A4960_MASK;

typedef struct __attribute__((__packed__)) tagRun {
    union {
        uint16_t val;
        struct {
            unsigned run:1;
            unsigned dir:1;
            unsigned brk:1;
            unsigned rsc:1;
            unsigned dg:2;
            unsigned esf:1;
            unsigned bw:3;
            unsigned bh:2;
            unsigned reg:4;
        };
    };
} A4960_RUN;

#define A4960_DIAGNOSTIC A4960_MASK

#endif    //UNDEF


/* Menu item definition */
typedef struct item_t {                //item structure
    const char* const name;
    const char* const unit;
    uint8_t point;
    uint8_t reg;
    uint16_t mask;
    uint16_t(*get)(struct item_t*);
    uint16_t(*set)(uint16_t, struct item_t*);
    uint16_t(*conv)(struct item_t*);
} ITEM;

/* Config field definition format */
typedef struct field_t {                
    const char* const title;            //what is printed on the screen        
    const char* const unit;             //unit of measurement
    uint8_t point;                      //decimal point
    uint8_t reg;                        //register
    uint16_t mask;                      //field mask 
    uint16_t(*conv)(struct field_t*);    //conversion utility
} FIELD;



void BSP_init(void);

uint16_t getField( FIELD* field );                  //get A4960 field
uint16_t setField( uint16_t val, FIELD* field );    //set A4960 field


#endif                                                             /* bsp_h */</text>
  </file>
  <file name="icbm.c">
   <text>/* Allegro A4960 BLDC test fixture main file */

#include &quot;qpn_port.h&quot;                                       /* QP-nano port */
#include &quot;bsp.h&quot;                             /* Board Support Package (BSP) */
#include &quot;icbm.h&quot;                            /* application interface */

/*..........................................................................*/
static QEvt l_consoleQueue[10];

/* QF_active[] array defines all active object control blocks --------------*/
QActiveCB const Q_ROM QF_active[] = {
    { (QActive *)0,           (QEvt *)0,      0U                    },
    { (QActive *)&amp;AO_Console,  l_consoleQueue,  Q_DIM(l_consoleQueue)  }
};

/* make sure that the QF_active[] array matches QF_MAX_ACTIVE in qpn_port.h */
//Q_ASSERT_COMPILE(QF_MAX_ACTIVE == Q_DIM(QF_active) - 1);

/*..........................................................................*/
int_t main () {

    BSP_init();                                     /* initialize the board */

    Console_ctor();

    return QF_run();                         /* transfer control to QF-nano */
}</text>
  </file>
  <file name="bsp.c">
   <text>/* Allegro A4960 BLDC test fixture board support package */
#include &quot;qpn_port.h&quot;
#include &quot;bsp.h&quot;
#include &quot;icbm.h&quot;
#include &lt;libpic30.h&gt;
//rev0 notes
//1.console on UART1
//SPI1
//CS on pin 25

/* PIC24FV16KM202-specific */

/* MCU configuration bits                      */
/* external 8 MHz crystal w/PLL, 32MHz clock   */
#pragma config BWRP=OFF, BSS=OFF, GWRP=OFF, GCP=OFF
#pragma config FNOSC = PRIPLL, SOSCSRC = DIG, LPRCSEL = LP, IESO = ON
#pragma config POSCMOD = HS, OSCIOFNC = CLKO, POSCFREQ = MS, FCKSM = CSECME
#pragma config FWDTEN = OFF, WINDIS = OFF
#pragma config BOREN=BOR0, RETCFG=OFF, PWRTEN = OFF, MCLRE=ON
#pragma config ICS = PGx2

/* Local-scope objects -----------------------------------------------------*/
                             /* frequency of the oscillator for PIC24 */
#define FOSC_HZ                 32000000.0
                                       /* instruction cycle clock frequency */
#define FCY_HZ                  (FOSC_HZ / 2.0)

                                /* controlling the LED */
#define LED_ON()                //(LATA |= (1U &lt;&lt; 0))
#define LED_OFF()               //(LATA &amp;= ~(1U &lt;&lt; 0))
#define LED_TOGGLE()            //(LATA ^= (1U &lt;&lt; 0))

/* Peripherals                                -----------------------------*/

#define MISO_TRIS _TRISA7
#define TACHO_TRIS _TRISB9
#define DIAG_TRIS _TRISB3
#define RBUT_TRIS _TRISA0
#define RBUT_PIN _RA0
#define BBUT_TRIS _TRISA1
#define BBUT_PIN _RA1

/* High Endurance EEPROM        ------------------------------------------*/
#define EE_SIZE 256U                 //x16 bit
#define HEE_PAGES 4U                  //more than 2 to detect
                                     //failed pack
#define HEE_PAGESIZE EE_SIZE/HEE_PAGES

#define EE_ROW_SIZE 8U               //8 words erase max
#define EE_ROWS 8U

#define EE_ERASE_8    0x1a        
#define EE_ERASE_4    0x19
#define EE_ERASE_1    0x18
#define EE_ERASE_ALL  0x10  
#define EE_WRITE   0x04

//EEPROM Write queue size - must be power of 2
#define HEEQ_BUFSIZE 64
#define HEEQ_BUFMASK ( HEEQ_BUFSIZE - 1 )

#if ( HEEQ_BUFSIZE &amp; HEEQ_BUFMASK )
#error EEPROM Write queue size is not a power of 2
#endif

typedef union
{
    uint8_t val;
    struct
    {
        unsigned addrNotFound:1;        // Return 0xFFFF
        unsigned expiredPage:1;               // Return 0x1
        unsigned packBeforePageFull:1;    // Not a return condition
        unsigned packBeforeInit:1;        // Return 0x3
        unsigned packSkipped:1;            // Return 0x4
        unsigned IllegalAddress:1;        // Return 0x5
        unsigned pageCorrupt:1;            // Return 0x6
        unsigned writeError:1;            // Return 0x7
    };
} HEE_FLAGS;

typedef struct __attribute__((__packed__)) heep_t {    //page status 
    union {
        uint16_t val;
        struct {
            unsigned count:13;
            unsigned expired:1;
            unsigned available:1;
            unsigned current:1;
        };
    };
} HEE_PAGE_STATUS;

typedef struct heeq_t {    //EEPROM modification request
    uint16_t data;    
    _prog_addressT addr;
    uint8_t op;
} HEE_REQ;

//todo: check if zeroing it at programming is certain
__eds__ const uint16_t heep[4][64] __attribute__((space(eedata), aligned(2)));


//EEPROM WR Queue
HEE_REQ heeq[HEEQ_BUFSIZE];
uint8_t heeq_Head;
volatile uint8_t heeq_Tail;    //interrupt changes this

/* A4960 */

#define A4960_CS_PIN _RB15


#define TIMER1_ISR_PRIO         4

//- Const

//Enable-disable message
const char const zen[] = &quot;\x08\x08\x08 0 - Enable, 1- Disable&quot;;

//Common units

const char const us[] = &quot;us&quot;;    //microseconds
//const char const ns[] = &quot;ns&quot;;    //nanoseconds

//- Static

static uint8_t tach_ro;    //rollover count for Tacho 

/* ISRs --------------------------------------------------------------------*/
$define(BSP::ISR::_AddressError)
$define(BSP::ISR::_StackError)
$define(BSP::ISR::_T1Interrupt)

$define(BSP::Tacho::_CCT2Interrupt)
$define(BSP::Tacho::_CCP2Interrupt)

$define(BSP::HEE::_NVMInterrupt)

$define(BSP::A4960::Common::SPI_init)
$define(BSP::A4960::Common::A4960_xfer)
$define(BSP::A4960::Common::A4960_getField)
$define(BSP::A4960::Common::A4960_setField)
$define(BSP::A4960::Common::getField)
$define(BSP::A4960::Common::setField)

$define(BSP::A4960::Common::A4960_convPercent)

//- Limits
$define(BSP::A4960::Limits::A4960_ConvCommBlankTime)
$define(BSP::A4960::Limits::ConvCommBlankTime)
$define(BSP::A4960::Limits::A4960_ConvBlankTime)
$define(BSP::A4960::Limits::A4960_ConvDeadTime)
//- Common ConvPercent
$define(BSP::A4960::Limits::A4960_ConvVdsThreshold)

/* Item access structure. Layout as follows:

name - what is printed in the menu
unit - what is printed after the value
point - decimal point
reg - register containing the item
mask - bitmask of an item inside the register
get - function to get contents --&gt;redundant?
set - function to set contents --&gt;same as above
conv - function to convert contents to value
*/

FIELD const CommBlankTime =
    {&quot;Commutation Blank Time&quot;, us, 0U, A4960_CONF0_RD, 0x0c00,
        &amp;ConvCommBlankTime};




ITEM const A4960_CommBlankTime = 
    {&quot;Comm. Blank Time&quot;, zen/*&quot;ns&quot;*/, 0U, A4960_CONF0_RD, 0x0c00,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvCommBlankTime};

ITEM const A4960_BlankTime = 
    {&quot;Blank Time&quot;,&quot;us&quot;, 3U, A4960_CONF0_RD, 0x03c0,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvBlankTime};

ITEM const A4960_DeadTime = 
    {&quot;Dead Time&quot;,&quot;ns&quot;, 0U, A4960_CONF0_RD, 0x003f,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvDeadTime};

ITEM const A4960_CurrentSenseRefRatio = 
    {&quot;Current Sense&quot;,&quot;%&quot;, 2U, A4960_CONF1_RD, 0x03c0,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_convPercent};

ITEM const A4960_VdsThreshold = 
    {&quot;VDS Threshold&quot;,&quot;mV&quot;, 0U, A4960_CONF1_RD, 0x003f,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvVdsThreshold};


/* ----------------------------- */

//- Run
$define(BSP::A4960::Run::A4960_ConvFixedOffTime)
$define(BSP::A4960::Run::A4960_ConvPhaseAdvance)
//BemfHyst - get
$define(BSP::A4960::Run::A4960_ConvBemfWindow)
//Brake - get
//Direction - get
//Run - get


ITEM const A4960_FixedOffTime = 
    {&quot;Fixed Off Time&quot;, &quot;us&quot;, 1U, A4960_CONF2_RD, 0x001f,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvFixedOffTime};

ITEM const A4960_PhaseAdvance = 
    {&quot;Phase Advance&quot;,&quot;deg(e)&quot;, 3U, A4960_CONF5_RD, 0x0c00,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvPhaseAdvance};

ITEM const A4960_BemfHyst = 
    {&quot;BEMF Hysteresis&quot;,&quot;0 - Auto, 1 - None, 2 - High, 3 - Low&quot;, 0U, A4960_RUN_RD, 0x0c00,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_BemfWindow = 
    {&quot;BEMF Window&quot;,&quot;us&quot;, 0U, A4960_RUN_RD, 0x0380,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvBemfWindow};

ITEM const A4960_Brake = 
    {&quot;Brake&quot;,&quot;0 - Off, 1 - On&quot;, 0U, A4960_RUN_RD, 0x0004,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_Direction = 
    {&quot;Direction&quot;,&quot;0 - Fwd, 1 - Rev&quot;, 0U, A4960_RUN_RD, 0x0002,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_Run = 
    {&quot;Run&quot;,&quot;0 - Coast, 1 - Run&quot;, 0U, A4960_RUN_RD, 0x0001,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};


//HoldTorque - percent
$define(BSP::A4960::Startup::A4960_ConvHoldTime)
$define(BSP::A4960::Startup::A4960_ConvEndCommTime)
$define(BSP::A4960::Startup::A4960_ConvStartCommTime)
//ForcedCommTorque - A_ConvPercent
$define(BSP::A4960::Startup::A4960_ConvRampRate)

ITEM const A4960_HoldTorque = 
    {&quot;Hold Torque&quot;, &quot;%&quot;, 2U, A4960_CONF3_RD, 0x00f0,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_convPercent};

ITEM const A4960_HoldTime = 
    {&quot;Hold Time&quot;, &quot;ms&quot;, 0U, A4960_CONF3_RD, 0x000f,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvHoldTime};

ITEM const A4960_EndCommTime = 
    {&quot;End Comm. Time&quot;, &quot;ms&quot;, 0U, A4960_CONF4_RD, 0x00f0,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvEndCommTime};

ITEM const A4960_StartCommTime = 
    {&quot;Start Comm. Time&quot;, &quot;ms&quot;, 0U, A4960_CONF4_RD, 0x000f,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvStartCommTime};

ITEM const A4960_ForcedCommTorque = 
    {&quot;Forced Comm. Ramp-up Torque&quot;, &quot;%&quot;, 2U, A4960_CONF5_RD, 0x00f0,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_convPercent};

ITEM const A4960_RampRate = 
    {&quot;Ramp Rate&quot;, &quot;ms&quot;, 1U, A4960_CONF5_RD, 0x000f,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_ConvRampRate};

//Flags - all generic

ITEM const A4960_VaFlag = 
    {&quot;Bootcap A Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0100,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_VbFlag = 
    {&quot;Bootcap B Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0080,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_VcFlag = 
    {&quot;Bootcap C Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0040,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_AhFlag = 
    {&quot;Phase A High-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0020,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_AlFlag = 
    {&quot;Phase A Low-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0010,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_BhFlag = 
    {&quot;Phase B High-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0008,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_BlFlag = 
    {&quot;Phase B Low-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0004,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_ChFlag = 
    {&quot;Phase C High-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0002,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_ClFlag = 
    {&quot;Phase C Low-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0001,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

//- Misc all generic

ITEM const A4960_TorqueCtlMethod = 
    {&quot;Torque Control Method&quot;, &quot;0 - Current, 1 - Duty Cycle&quot;, 0U, A4960_CONF3_RD, 0x0100,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_EnableStopOnFail = 
    {&quot;Stop on Fail&quot;,&quot;0 - Dis, 1- En&quot;, 0U, A4960_RUN_RD, 0x0040,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_DiagOutput = 
    {&quot;Diag Output&quot;,&quot;0 - Flt, 1 - LOS, 2 -VDS Thr, 3 - clock&quot;, 0U, A4960_RUN_RD, 0x0030,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_RestartControl = 
    {&quot;Restart Control&quot;,&quot;0 - Dis, 1 - En&quot;, 0U, A4960_RUN_RD, 0x0080,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_TwFlag = 
    {&quot;Temperature Warning Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0800,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_TsFlag = 
    {&quot;Thermal Shutdown Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0400,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};

ITEM const A4960_LosFlag = 
    {&quot;BEMF Sync. Loss Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0200,
        &amp;A4960_getField, &amp;A4960_setField, &amp;A4960_getField};


//- PWM access

//One of the 8 pre-determined frequencies

static const uint16_t pwmPeriod[] = { 64000U, 32000U, 16000U,
    8000U, 3200U, 1600U, 800U, 320U };

static const uint16_t pwmFreq[] = { 250U, 500U, 1000U,
    2000U, 5000U, 10000U, 20000U, 50000U };

$define(BSP::PWM::PWM_init)
$define(BSP::PWM::PWM_idxLookup)
$define(BSP::PWM::PWM_getPeriodIdx)

$define(BSP::PWM::PWM_setPeriod)
$define(BSP::PWM::PWM_convFreq)
$define(BSP::PWM::PWM_getDuty)
$define(BSP::PWM::PWM_setDuty)

ITEM const PWM_Freq =
    {&quot;PWM Frequency&quot;, &quot;kHz&quot;, 3U, 0U, 0x07,
        &amp;PWM_getPeriodIdx, &amp;PWM_setPeriod, &amp;PWM_convFreq};

ITEM const PWM_Duty =
    {&quot;PWM Duty Cycle&quot;, &quot;%&quot;, 0U, 0U, 0x00,
        &amp;PWM_getDuty, &amp;PWM_setDuty, &amp;PWM_getDuty};


$define(BSP::HEE::HEE_init)

$define(BSP::Tacho::Tacho_init)
$define (BSP::BSP_init)

#ifdef UNDEF
/*--------------------------------------------------------------------------*/
void BSP_init(void) {
    RCONbits.SWDTEN = 0;                                /* disable Watchdog */

    TRISA = 0x00;                                /* set LED pins as outputs */
    PORTA = 0x00;                               /* set LEDs drive state low */
    TRISB = 0x00;
    PORTB = 0x00;
    ANSA = 0x00;
    ANSB = 0x00;

    TACHO_TRIS = 1;    //tachometer input
    DIAG_TRIS = 1;     //diag pin input

    SPI_init();
    PWM_init();
    Tacho_init();
    HEE_init();
}

#endif

$define(BSP::QPn::QF_onStartup)
$define(BSP::QPn::QF_onIdle)
$define(BSP::QPn::Q_onAssert)
</text>
  </file>
  <file name="console.c">
   <text>/* Interactive Controller for Brushless Motors serial console AO */
#include &quot;qpn_port.h&quot;
#include &quot;icbm.h&quot;
#include &quot;bsp.h&quot;
#include &quot;libpic30.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

// A4960

//- Access to 'Limits' fields
extern FIELD const CommBlankTime;

//- Access to 'Limits' fields
extern ITEM const A4960_CommBlankTime;
extern ITEM const A4960_BlankTime;
extern ITEM const A4960_DeadTime;
extern ITEM const A4960_CurrentSenseRefRatio;
extern ITEM const A4960_VdsThreshold;

//- Access to 'Run' fields
extern ITEM const A4960_FixedOffTime;
extern ITEM const A4960_PhaseAdvance;
extern ITEM const A4960_BemfHyst;
extern ITEM const A4960_BemfWindow;
extern ITEM const A4960_Brake;
extern ITEM const A4960_Direction;
extern ITEM const A4960_Run;

//- Access to 'Startup' fields
extern ITEM const A4960_HoldTorque;
extern ITEM const A4960_HoldTime;
extern ITEM const A4960_EndCommTime;
extern ITEM const A4960_StartCommTime;
extern ITEM const A4960_ForcedCommTorque;
extern ITEM const A4960_RampRate;

//- Access to 'Flags' fields
extern ITEM const A4960_VaFlag;
extern ITEM const A4960_VbFlag;
extern ITEM const A4960_VcFlag;
extern ITEM const A4960_AhFlag;
extern ITEM const A4960_AlFlag;
extern ITEM const A4960_BhFlag;
extern ITEM const A4960_BlFlag;
extern ITEM const A4960_ChFlag;
extern ITEM const A4960_ClFlag;

//- Access to 'Misc' fields
extern ITEM const A4960_TorqueCtlMethod;
extern ITEM const A4960_EnableStopOnFail;
extern ITEM const A4960_DiagOutput;
extern ITEM const A4960_RestartControl;
extern ITEM const A4960_TwFlag;
extern ITEM const A4960_TsFlag;
extern ITEM const A4960_LosFlag;

//- Access to PWM
extern ITEM const PWM_Freq;
extern ITEM const PWM_Duty;

#define BAUD_RATE_CONSOLE 115200UL
//Console TX buffer size - must be power of 2
#define CONSOLE_BUFSIZE 64
#define CONSOLE_BUFMASK ( CONSOLE_BUFSIZE - 1 )

#if ( CONSOLE_BUFSIZE &amp; CONSOLE_BUFMASK )
#error Serial Tx Buffer size is not a power of 2
#endif

//#define CONSOLE_RX_PIN _RB2
#define CONSOLE_RX_TRIS _TRISB2

#define ROLL_TOUT BSP_TICKS_PER_SEC/10   //whirling star animation
#define STAT_TOUT BSP_TICKS_PER_SEC/5    //status line update rate

/* Variables */
//Serial console
//__pack_upper_byte uint8_t* consoleBuf[CONSOLE_BUFSIZE];
const char* consoleBuf[CONSOLE_BUFSIZE];
uint8_t consoleHead;
volatile uint8_t consoleTail;    //interrupt changes this



static const char* const crlf = &quot;\r\n&quot;;

static const char* const space = &quot; &quot;;

/*-- Main Menu */
//const char* mSetup[] = {&quot;Setup&quot;};

//static const char* const mSetup = &quot;Setup&quot;;
//const char* const mMess = &quot;Mess&quot;;
//const char* const mTune = &quot;Tune&quot;;

const char* menuMain[] = 
    { &quot;Setup&quot;, &quot;Mess&quot;, &quot;Tune&quot; };
#define MENU_MAIN_CNT Q_DIM(menuMain)

/*-- Setup Menu and accompanying menu item arrays */
const char* const menuSetup[] = 
    { &quot;Startup&quot;, &quot;Ui&quot; };
#define MENU_SETUP_CNT Q_DIM(menuSetup)

const ITEM* const controlItems[] = {&amp;PWM_Freq};
#define CONTROL_CNT Q_DIM(controlItems)

const ITEM* const uiItems[] = {};
#define UI_CNT Q_DIM(uiItems)

/*- Mess Menu and accompanying menu item arrays */


const char* const menuMess[] = {&quot;Limits&quot;,&quot;Run&quot;,&quot;Startup&quot;,&quot;Flags&quot;,&quot;Misc&quot;};
#define MENU_MESS_CNT Q_DIM(menuMess)

const ITEM* const limitsItems[] = {&amp;A4960_CommBlankTime, &amp;A4960_BlankTime,
    &amp;A4960_DeadTime, &amp;A4960_CurrentSenseRefRatio, &amp;A4960_VdsThreshold};
#define LIMITS_CNT Q_DIM(limitsItems)

const FIELD* const limitsFields[] = {&amp;CommBlankTime,&amp;CommBlankTime,&amp;CommBlankTime};
#define LIMITS_COUNT Q_DIM(limitsFields)





const ITEM* const runItems[] =
    {&amp;A4960_FixedOffTime, &amp;A4960_PhaseAdvance, &amp;A4960_BemfHyst,
     &amp;A4960_BemfWindow, &amp;A4960_Brake, &amp;A4960_Direction, &amp;A4960_Run};
#define RUN_CNT Q_DIM(runItems)

const ITEM* const startupItems[] =
    {&amp;A4960_HoldTorque, &amp;A4960_HoldTime, &amp;A4960_EndCommTime,
     &amp;A4960_StartCommTime, &amp;A4960_ForcedCommTorque, &amp;A4960_RampRate};
#define STARTUP_CNT Q_DIM(startupItems)

const ITEM* const flagsItems[] = 
    {&amp;A4960_VaFlag, &amp;A4960_VbFlag, &amp;A4960_VcFlag, &amp;A4960_AhFlag,
     &amp;A4960_AlFlag, &amp;A4960_BhFlag, &amp;A4960_BlFlag, &amp;A4960_ChFlag,
     &amp;A4960_ClFlag};
#define FLAGS_CNT Q_DIM(flagsItems)

const ITEM* const miscItems[] =
    {&amp;A4960_TorqueCtlMethod, &amp;A4960_EnableStopOnFail, &amp;A4960_DiagOutput,
     &amp;A4960_RestartControl, &amp;A4960_TwFlag, &amp;A4960_TsFlag, &amp;A4960_LosFlag};
#define MISC_CNT Q_DIM(miscItems)

const char* const menuTune[]={&quot;Tune&quot;,&quot;Tune&quot;};
#define MENU_TUNE_CNT Q_DIM(menuTune)

/* local objects -----------------------------------------------------------*/
$declare(AOs::Tacho)
$declare(AOs::Console)

/* global objects ----------------------------------------------------------*/
Console AO_Console;

/* Active object definition ================================================*/
$define(AOs::Console_ctor)
$define(AOs::Console)
$define(AOs::Tacho)

/*-- Interrupts */
$define(BSP::ISR::_U1RXInterrupt)
$define(BSP::ISR::_U1TXInterrupt)
$define(BSP::ISR::_U1ErrInterrupt)</text>
  </file>
  <file name="icbm.h">
   <text>/* Allegro A4960 BLDC test fixture main header */
#ifndef bldc_meter_h
#define bldc_meter_h

/* from MC controller RPM = (FG*720)/P*S */


#define REV &quot;0&quot;

enum BldcMeterSignals {                       /* signals used in the meter */
    
    TIME_TICK_SIG = Q_USER_SIG,
    WCOL_SIG,    //SPI write collision
    /**/
    TACHO_SIG,
    TACHO_TIMEOUT_SIG,
    RPM_SIG,
    FF_SIG,
    KBD_KEY_SIG,
    RBUT_PRESS_SIG,
    RBUT_RELEASE_SIG,
    BBUT_PRESS_SIG,
    BBUT_RELEASE_SIG
};
/* Access to A4960 fields */

/* active objects ..........................................................*/
extern struct Console  AO_Console;

$declare(AOs::Console_ctor)

#endif                                                      /* bldc_meter_h */</text>
  </file>
  <file name="qpn_port.h">
   <text>/* Allegro A4960 BLDC test fixture QP-nano port header */
#ifndef qpn_port_h
#define qpn_port_h

#define Q_NFSM
#define Q_NHSM
#define Q_PARAM_SIZE            4
#define QF_TIMEEVT_CTR_SIZE     2
//#define QF_MAX_TICK_RATE 4

/* maximum # active objects--must match EXACTLY the QF_active[] definition  */
#define QF_MAX_ACTIVE           1U

                         /* task-level interrupt nesting policy, see NOTE01 */
#define QF_INT_DISABLE()        __builtin_disi(0x3FFFU)
#define QF_INT_ENABLE()         __builtin_disi(0x0000U)

          /* ISR-level interrupt locking policy for PIC24/dsPIC, see NOTE02 */
#define QF_ISR_NEST

                           /* fast log-base-2 with FBCL instruction, NOTE03 */
#define QF_LOG2(n_) ((uint8_t)(15 + __builtin_fbcl(n_)))

             /* Exact-width types. WG14/N843 C99 Standard, Section 7.18.1.1 */
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;

#include &quot;qepn.h&quot;         /* QEP-nano platform-independent public interface */
#include &quot;qfn.h&quot;           /* QF-nano platform-independent public interface */


/*****************************************************************************
* NOTE01:
* The DISI (disable interrupts) instruction is used for very fast,
* unconditional locking and unlocking of interrupts. The DISI #0x3FFF
* instruction disables interrupts for 16383 instruction cycles, which is
* much longer than any critical section in QP-nano. The DISI #0 instruction
* is then used to unconditionally unlock the interrupts at the end of the
* critical section. The DISI instruction only disables interrupts with
* priority levels 1-6. Priority level 7 interrupts and all trap events still
* have the ability to interrupt the CPU when the DISI instruction is active.
* This means that from the perspective of QP-nano, the level 7 interrupts are
* treated as non-maskable interrupts (NMIs). Such non-maskable interrupts
* _cannot_ call any QP-nano services. In particular, they cannot post events.
*
* CAUTION: This QP-nano port assumes that interrupt nesting is _enabled_,
* which is the default in the PIC24/dsPIC processors. Interrupt nesting should
* never be disabled by setting the NSTDIS control bit (INTCON1&lt;15&gt;). If you
* don't want interrupts to nest, you can always prioritize them at the same
* level. For example, the default priority level for all interrupts is 4 out
* of reset. If you don't change this level for any interrupt the nesting of
* interrupt will not occur.
*
* NOTE02:
* The ISR-level interrupt policy allows interrupt nesting. The QF_ISR_KEY_TYPE
* is _not_ defined, which means that the ISRs will use the task-level
* interrupt locking policy. This is possible, because PIC245/dsPIC CPU does
* _not_ lock interrupts upon entry to the ISR, so the ISR does not constitute
* critical section and the simple critical section incapable of nesting is
* adequate.
*
* NOTE03:
* The FBCL instruction (Find First Bit Change Left) determines the exponent
* of a value by detecting the first bit change starting from the value’s sign
* bit and working towards the LSB. Since the PIC24/dsPIC’s barrel shifter
* uses negative values to specify a left shift, the FBCL instruction returns
* the negated exponent of a value. This value added to 15 gives the log-2.
*/

#endif                                                        /* qpn_port_h */</text>
  </file>
  <file name="README.md">
   <text>Interactive Controller for Brushless Motors source code

Alpha code - do not expect anything. Compiles on xc ver 1.23 but throws weird linker error
in 1.24. Have not tested on 1.25.</text>
  </file>
 </directory>
</model>
