<?xml version="1.0" encoding="UTF-8"?>
<model version="3.3.0">
 <documentation>Interface to Allegro A4960 BLDC pre-driver</documentation>
 <framework name="qpn"/>
 <package name="AOs" stereotype="0x02">
  <class name="Console" superclass="qpn::QMActive">
   <attribute name="menuselect" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>stores value of selected menu item, if necessary to keep between states</documentation>
   </attribute>
   <attribute name="rpm" type="uint16_t" visibility="0x02" properties="0x00">
    <documentation>motor RPM</documentation>
   </attribute>
   <attribute name="diag" type="uint16_t" visibility="0x00" properties="0x00">
    <documentation>storage for diagnostic output</documentation>
   </attribute>
   <attribute name="tacho" type="Tacho" visibility="0x00" properties="0x00"/>
   <attribute name="blinke" type="Blinke" visibility="0x00" properties="0x00">
    <documentation>LED control state machine instance</documentation>
   </attribute>
   <operation name="printStr" type="void" visibility="0x02" properties="0x01">
    <documentation>places pointer to a const string to serial buffer</documentation>
    <parameter name="str" type="const char*"/>
    <code>uint8_t tmphead = consoleHead + 1;

#if CONSOLE_BUFMASK &lt; 255
tmphead &amp;= CONSOLE_BUFMASK;
#endif

while(tmphead == consoleTail) {}     //this line blocks!

consoleBuf[tmphead] = str;
consoleHead = tmphead;

if( _U1TXIE == 0) {    //trigger interrupt
    _U1TXIF = 1;
    _U1TXIE = 1;
}

return;</code>
   </operation>
   <operation name="printNum" type="void" visibility="0x02" properties="0x01">
    <documentation>decimal 'point' from the right</documentation>
    <parameter name="num" type="uint32_t"/>
    <parameter name="base" type="uint8_t"/>
    <parameter name="point" type="uint8_t"/>
    <code>#define CHAR_BUFSIZE 33
const char* const numchars[] = {&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,
    &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;};
const char* buf[CHAR_BUFSIZE];
const char** pStr = &amp;(buf[CHAR_BUFSIZE-1]);

do {
    *(--pStr) = numchars[num % base];
    num /= base;
    } while( num != 0 );

while( pStr &lt; &amp;buf[CHAR_BUFSIZE-1] ) {    //copy the buffer into the queue
    if((&amp;buf[CHAR_BUFSIZE-1] - pStr) == point) {
        Console_printStr(&quot;.&quot;);                       //print decimal point
    }    
    Console_printStr(*pStr++);
}</code>
   </operation>
   <operation name="printWhirlingStar" type="void" visibility="0x02" properties="0x01">
    <code>#define IDX_MASK 3
const char* const rollchar[4] = {&quot;/&quot;,&quot;-&quot;,&quot;\\&quot;,&quot;|&quot;};
static uint8_t idx = 0;

Console_printStr(&quot;\x08&quot;);    //backspace

Console_printStr(rollchar[idx++]);

idx &amp;= IDX_MASK;</code>
   </operation>
   <operation name="printMenuTitle" type="void" visibility="0x02" properties="0x01">
    <parameter name="count" type="uint8_t"/>
    <parameter name="menu" type="const char* const*"/>
    <code>uint8_t i;

Console_printStr(crlf);

for(i = 0; i &lt;= count; i++) {
    Console_printNum(i,10,0U);
    Console_printStr(&quot;. &quot;);
    
    if (i == 0) {
        Console_printStr(&quot;Back&quot;);
    }
    else {
        Console_printStr(menu[i-1]);
    }

    Console_printStr(crlf);
}//for...

Console_printStr(crlf);</code>
   </operation>
   <operation name="printMenuItems" type="void" visibility="0x02" properties="0x00">
    <documentation>Prints set of items defined by array of pointers to access methods</documentation>
    <parameter name="field" type="FIELD**"/>
    <parameter name="cnt" type="uint8_t"/>
    <code>uint8_t i;

Console_printStr(&quot;\r\nPress number to select field,&quot;
                 &quot;\r\nthen w,a,s,d to change it.&quot;
                 &quot;\r\n\n0. Back&quot;);

//Console_printStr(&quot;\r\nPress number to select field,&quot;);
//Console_printStr(&quot;\r\nthen w,a,s,d to change it&quot;);
//Console_printStr(&quot;\r\n\n0. Back&quot;);

Console_printStr(crlf);

for(i = 0; i &lt; cnt; i++) {
    if(i+1 == me-&gt;menuselect) {    //highlight
        Console_printStr(&quot;&gt;&gt;&gt; &quot;);
    } else {
        Console_printNum(i+1, 10, 0U);
        Console_printStr(&quot;. &quot;);
    }

    Console_printStr(field[i]-&gt;title);    //field name

    Console_printStr(&quot; [&quot;);
    Console_printNum(getField(&amp;(*field[i])), 2, 0U);    //field contents, binary

    Console_printStr(&quot;], &quot;);

    //if(field[i]-&gt;conv) {    //conversion needed
        Console_printNum(field[i]-&gt;conv(&amp;(*field[i])),
                         10,
                         field[i]-&gt;point);           //field contents, converted
    //} else {
    //    Console_printNum(getField(&amp;(*field[i])),
    //                     10,
    //                     field[i]-&gt;point);             //field contents, decimal
    //}
                
    Console_printStr(space);
    Console_printStr(field[i]-&gt;unit);        //field unit
    Console_printStr(crlf);
}
Console_printStr(crlf);</code>
   </operation>
   <operation name="handleMenuItems" type="void" visibility="0x02" properties="0x00">
    <parameter name="key" type="uint8_t"/>
    <parameter name="field" type="FIELD**"/>
    <parameter name="cnt" type="uint8_t"/>
    <code>uint8_t tmpdata = atoi((const char*)&amp;key);

if(isdigit(key)) {    //numeric
    if(tmpdata &gt; cnt) {
        return;    //wrong key, do not handle
    }
    else {
        me-&gt;menuselect = tmpdata;    //remember selection
        return;
    }
}

if(me-&gt;menuselect == 0) {
    return;    //no further processing necessary
}

//tmpdata =
//    item[me-&gt;menuselect-1]-&gt;get(&amp;(*item[me-&gt;menuselect-1]));
tmpdata = getField(&amp;(*field[me-&gt;menuselect-1]));

if(key == 'w' || key == 'W') {    //increment
    tmpdata++;
}

if(key == 's' || key == 'S') {    //decrement
    tmpdata--;
}

uint16_t tmplen = field[me-&gt;menuselect-1]-&gt;mask;

while((tmplen &amp; 0x01) == 0 ) { //LSB eq zero
    tmplen &gt;&gt;= 1;
}

tmpdata &amp;= tmplen;

setField(tmpdata,&amp;(*field[me-&gt;menuselect-1]));
//field[me-&gt;menuselect-1]-&gt;set(tmpdata,&amp;(*item[me-&gt;menuselect-1]));</code>
   </operation>
   <operation name="Tacho_ctor" type="void" visibility="0x02" properties="0x01">
    <parameter name="me" type="Tacho* const"/>
    <code>QMsm_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Tacho_initial));</code>
   </operation>
   <operation name="Blinke_ctor" type="void" visibility="0x02" properties="0x01">
    <parameter name="me" type="Blinke* const"/>
    <code>QMsm_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Blinke_initial));</code>
   </operation>
   <statechart>
    <initial target="../1/9">
     <action>QActive_armX((QActive*)me, 0U, ROLL_TOUT);</action>
     <initial_glyph conn="8,2,5,0,1,33">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Session">
     <entry>//QActive_armX((QActive*)me, 1U, TACH_TOUT);</entry>
     <tran trig="WCOL">
      <action>Console_printStr(&quot;\r\nA4960 SPI Write collision&quot;);</action>
      <tran_glyph conn="4,67,3,-1,7">
       <action box="0,-2,7,2"/>
      </tran_glyph>
     </tran>
     <tran trig="FF">
      <action>//Fault reported

//uint8_t i =
//    A4960_TwFlag.get((struct item_t*)&amp;A4960_TwFlag);

//me-&gt;diag =
//    A4960_TwFlag.set(i, (struct item_t*)&amp;A4960_TwFlag);

uint8_t i = getField((struct field_t*)&amp;TwFlag);
me-&gt;diag = setField(i, (struct field_t*)&amp;TwFlag);

Console_printStr(&quot;\r\nA4960 fault&quot;);</action>
      <tran_glyph conn="4,70,3,-1,3">
       <action box="0,-2,4,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TICK">
      <action brief="dispatch">Q_SIG(&amp;me-&gt;tacho) = Q_SIG(me);
QMSM_DISPATCH((QMsm*)&amp;me-&gt;tacho);
Q_SIG(&amp;me-&gt;blinke) = Q_SIG(me);
QMSM_DISPATCH((QMsm*)&amp;me-&gt;blinke);</action>
      <tran_glyph conn="4,126,3,-1,22">
       <action box="0,-2,19,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TACHO">
      <action brief="dispatch">Q_SIG((QMsm*)&amp;me-&gt;tacho) = Q_SIG(me);
Q_PAR((QMsm*)&amp;me-&gt;tacho) = Q_PAR(me);
QMSM_DISPATCH((QMsm*)&amp;me-&gt;tacho);
//Console_printStr(&quot;Tacho&quot;);

//QActive_disarmX((QActive*)me, 3U);
//QActive_armX((QActive*)me, 3U, TACH_TOUT);</action>
      <tran_glyph conn="4,122,3,-1,22">
       <action box="0,-2,13,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RPM">
      <action>me-&gt;rpm = Q_PAR(me);</action>
      <tran_glyph conn="4,79,3,-1,4">
       <action box="0,-2,5,2"/>
      </tran_glyph>
     </tran>
     <tran trig="Q_TIMEOUT">
      <action brief="print status line">static const char* const diag_flags[] =
    {&quot;FF &quot;,&quot;POR &quot;,&quot;VR &quot;,&quot;?? &quot;,&quot;TW &quot;,&quot;TS &quot;,&quot;LOS &quot;,&quot;VA &quot;,&quot;VB &quot;,
    &quot;VC &quot;,&quot;AH &quot;,&quot;AL &quot;,&quot;BH &quot;,&quot;BL &quot;,&quot;CH &quot;,&quot;CL &quot;};


/* Status line output */
Console_printStr(&quot;\rSpeed: &quot;);
Console_printNum(me-&gt;rpm, 10, 0U);

//run flags
Console_printStr(&quot; [ &quot;);

if(getField((struct field_t*)&amp;Run)) {    //run flag up
   Console_printStr(&quot;RUN &quot;);
}
if(getField((struct field_t*)&amp;Brake)) {    //brake flag up
    Console_printStr(&quot;BRK &quot;);
}
if(getField((struct field_t*)&amp;Direction)) {//dir flag up
    Console_printStr(&quot;DIR &quot;);
}

Console_printStr(&quot;]&quot;);

//diagnostic flags. I need to write to a register to get those
uint16_t tmpdata = A4960_xfer(A4960_RUN_RD,0U);         //read RUN register
uint16_t tmpdiag = A4960_xfer(A4960_RUN_WR,tmpdata);    //read diagnostic

Console_printStr(&quot; [ &quot;);
uint8_t i;

for(i = 0; i &lt; 16; i++) {
    if(tmpdiag &amp; 0x8000) {    //print flag if set
        Console_printStr(diag_flags[i]);
    }
    tmpdiag &lt;&lt;=1;
}
Console_printStr(&quot;]&quot;);

Console_printStr(&quot;   &quot;);
QActive_armX(&amp;me-&gt;super, 0U, STAT_TOUT);</action>
      <tran_glyph conn="4,64,3,-1,19">
       <action box="0,-2,20,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RBUT_PRESS">
      <action>Console_printStr(&quot;\r\n\r\nRun Button Pressed\r\n&quot;);

//A4960_Run.set(1, (struct item_t*)&amp;A4960_Run);

setField(1, (struct field_t*)&amp;Run);


//A4960_Run-&gt;name

//Console_printStr(A4960_Run.name);</action>
      <tran_glyph conn="4,73,3,-1,9">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RBUT_RELEASE">
      <action>Console_printStr(&quot;\r\n\r\nRun Button Released\r\n&quot;);</action>
      <tran_glyph conn="4,76,3,-1,11">
       <action box="0,-2,11,2"/>
      </tran_glyph>
     </tran>
     <state name="Main">
      <entry>Console_printStr(&quot;\r\nMain Menu: &quot;);
Console_printMenuTitle(MENU_MAIN_CNT, menuMain);</entry>
      <exit>me-&gt;menuselect = 0;    //reset menu selection</exit>
      <tran trig="KBD_KEY">
       <action>//Console_printStr(me,&quot;\r\nKey Pressed&quot;);

//U1TXREG = Q_PAR(me);

//U1TXREG = 'A';</action>
       <choice target="../../../10">
        <guard brief="1">(uint8_t)(Q_PAR(me)) == '1'</guard>
        <choice_glyph conn="30,20,5,3,31">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../11">
        <guard brief="2">(uint8_t)(Q_PAR(me)) == '2'</guard>
        <choice_glyph conn="30,20,4,3,10,4">
         <action box="0,7,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../12">
        <guard brief="3">(uint8_t)(Q_PAR(me)) == '3'</guard>
        <choice_glyph conn="30,20,4,3,28,3">
         <action box="1,18,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="13,20,5,-1,17">
        <action box="0,-2,9,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="13,13,13,12">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="Idle">
      <entry>//Console_printStr(&quot;\r\nPress any key to enter console..  &quot;);
//QActive_armX((QActive*)me, 1U, TACHO_TOUT);</entry>
      <exit>//QActive_disarmX(&amp;me-&gt;super, 0U);</exit>
      <tran trig="Q_TIMEOUT">
       <action>QActive_armX(&amp;me-&gt;super, 0U, ROLL_TOUT);
Console_printWhirlingStar();</action>
       <tran_glyph conn="7,42,3,-1,8">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="KBD_KEY" target="../../8">
       <action>Console_printStr(&quot;\r\nInteractive Controller for Brushless Motors Console rev.&quot;);
Console_printStr(REV);
Console_printStr(&quot;\r\nCompiled on &quot;);
Console_printStr(__DATE__);
Console_printStr(&quot; at &quot;);
Console_printStr(__TIME__);
Console_printStr(&quot; using Microchip XC16 C compiler ver.&quot;);
Console_printNum(__XC16_VERSION__, 10,0U);
Console_printStr(&quot;\r\n\n&quot;);</action>
       <tran_glyph conn="7,46,3,2,11,-21">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="7,35,16,18">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="Setup">
      <entry>Console_printStr(&quot;\r\nSetup Menu:&quot;);
Console_printMenuTitle(MENU_SETUP_CNT, menuSetup);</entry>
      <tran trig="KBD_KEY">
       <action>Console_printStr(&quot;\r\n&quot;);</action>
       <choice target="../..">
        <guard>else</guard>
        <choice_glyph conn="73,25,5,2,-8,-3">
         <action box="-6,-2,6,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../8">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="73,25,4,0,-14,-50,2">
         <action box="-4,-16,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../18">
        <guard brief="1">(uint8_t)(Q_PAR(me)) == '1'</guard>
        <choice_glyph conn="73,25,5,3,8">
         <action box="1,-2,10,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../19">
        <guard brief="2">(uint8_t)(Q_PAR(me)) == '2'</guard>
        <choice_glyph conn="73,25,4,3,12,8">
         <action box="0,10,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="61,20,3,-1,12,5">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="61,13,8,9">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Mess">
      <entry>Console_printStr(&quot;\r\nMess Menu:&quot;);
Console_printMenuTitle(MENU_MESS_CNT, menuMess);</entry>
      <exit>me-&gt;menuselect = 0;    //reset menu selection</exit>
      <tran trig="KBD_KEY">
       <action>Console_printStr(&quot;\r\n&quot;);</action>
       <choice target="../../../13">
        <guard brief="1">(uint8_t)(Q_PAR(me)) == '1'</guard>
        <choice_glyph conn="43,35,5,3,8">
         <action box="1,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../14">
        <guard brief="2">(uint8_t)(Q_PAR(me)) == '2'</guard>
        <choice_glyph conn="43,35,4,3,10,8">
         <action box="1,8,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../15">
        <guard brief="3">(uint8_t)(Q_PAR(me)) == '3'</guard>
        <choice_glyph conn="43,35,4,3,22,8">
         <action box="1,20,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../17">
        <guard brief="4">(uint8_t)(Q_PAR(me)) == '4'</guard>
        <choice_glyph conn="43,35,4,3,34,8">
         <action box="1,32,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../16">
        <guard brief="5">(uint8_t)(Q_PAR(me)) == '5'</guard>
        <choice_glyph conn="43,35,4,3,46,8">
         <action box="1,44,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../8">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="43,35,5,2,-20,-10">
         <action box="-10,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <choice_glyph conn="43,35,5,2,-7,-3">
         <action box="-6,-2,6,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="34,30,3,-1,9,5">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="34,22,8,10">
       <entry box="1,2,4,2"/>
       <exit box="1,4,4,2"/>
      </state_glyph>
     </state>
     <state name="Tune">
      <entry>Console_printStr(&quot;\r\nTune Menu:&quot;);
Console_printMenuTitle(MENU_TUNE_CNT, menuTune);</entry>
      <state_glyph node="33,42,9,9">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Limits">
      <documentation>Manipulating BLDC controller limits</documentation>
      <entry>//Console_printItems(me, (ITEM**)limitsItems, LIMITS_CNT);
Console_printMenuItems(me, (FIELD**)limitsFields, LIMITS_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../11">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="59,35,5,1,5,-9,-22">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>//Console_handleItems
//    (me,(uint8_t)Q_PAR(me),(ITEM**)limitsItems, LIMITS_CNT);

Console_handleMenuItems
    (me,(uint8_t)Q_PAR(me),(FIELD**)limitsFields, LIMITS_CNT);</action>
        <choice_glyph conn="59,35,4,3,-3,-8">
         <action box="-4,-5,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="51,35,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="51,27,10,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Run">
      <documentation>Manipulating run parameters</documentation>
      <entry>Console_printMenuItems(me, (FIELD**)runFields, RUN_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../11">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="59,45,5,1,5,-19,-22">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>Console_handleMenuItems
    (me, (uint8_t)Q_PAR(me), (FIELD**)runFields, RUN_CNT);</action>
        <choice_glyph conn="59,45,4,3,3,-8">
         <action box="-6,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="51,45,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="51,39,10,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Startup">
      <entry>Console_printMenuItems
    (me, (FIELD**)startupFields, STARTUP_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../11">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="59,57,5,1,5,-31,-22">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>Console_handleMenuItems
    (me, (uint8_t)Q_PAR(me), (FIELD**)startupFields,
    STARTUP_CNT);</action>
        <choice_glyph conn="59,57,4,3,3,-8">
         <action box="-6,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="51,57,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="51,51,10,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Misc">
      <entry>Console_printMenuItems
    (me,(FIELD**)miscFields, MISC_CNT);
</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../11">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="59,81,5,1,5,-55,-22">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>Console_handleMenuItems
    (me, (uint8_t)Q_PAR(me), (FIELD**)miscFields,
    MISC_CNT);</action>
        <choice_glyph conn="59,81,4,3,3,-8">
         <action box="-6,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="51,81,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="51,75,10,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Flags">
      <entry>Console_printStr(&quot;\r\nUse 'Misc' menu for non-bridge related faults&quot;);

Console_printMenuItems
    (me, (FIELD**)flagsFields, FLAGS_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../11">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="59,69,5,1,5,-43,-22">
         <action box="2,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>Console_handleMenuItems
    (me, (uint8_t)Q_PAR(me), (FIELD**)flagsFields,
    FLAGS_CNT);</action>
        <choice_glyph conn="59,69,4,3,3,-8">
         <action box="-6,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="51,69,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="51,63,10,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Control">
      <entry>//Console_printItems(me, (ITEM**)controlItems, CONTROL_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../10">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="89,25,5,1,8,-8,-28">
         <action box="4,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>//Console_handleItems
//    (me,(uint8_t)Q_PAR(me),(ITEM**)controlItems, CONTROL_CNT);</action>
        <choice_glyph conn="89,25,4,3,3,-8">
         <action box="-5,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="81,25,3,-1,8">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="81,19,11,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="UI">
      <entry>//Console_printItems(me, (ITEM**)uiItems, UI_CNT);</entry>
      <tran trig="KBD_KEY">
       <choice target="../../../10">
        <guard brief="0">(uint8_t)(Q_PAR(me)) == '0'</guard>
        <choice_glyph conn="88,37,5,1,9,-20,-28">
         <action box="5,-2,4,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>//Console_handleItems
//    (me,(uint8_t)Q_PAR(me),(ITEM**)uiItems, UI_CNT);</action>
        <choice_glyph conn="88,37,4,3,3,-7">
         <action box="-5,1,4,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="81,37,3,-1,7">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="81,31,11,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="4,5,96,132">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="167,145"/>
   </statechart>
  </class>
  <class name="Tacho" superclass="qpn::QMsm">
   <documentation>Tachometer output handler. Timeouts if no tachometer event has happened
in 0.5 sec., otherwise collects and processes tach data.</documentation>
   <attribute name="cnt" type="uint8_t" visibility="0x02" properties="0x00"/>
   <statechart>
    <initial target="../1">
     <initial_glyph conn="18,8,5,0,12,2">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Idle">
     <entry>QACTIVE_POST_X((QActive*)&amp;AO_Console, 1, RPM_SIG, 0U);    //send out zero RPM</entry>
     <tran trig="TACHO" target="../../2">
      <action>//Console_printStr(&quot;Tacho start&quot;);</action>
      <tran_glyph conn="16,19,3,1,19,10,-2">
       <action box="0,-2,5,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TICK">
      <tran_glyph conn="16,16,3,-1,13">
       <action box="0,-2,13,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="16,10,17,11">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state name="Process">
     <tran trig="TICK">
      <choice target="../../../1">
       <guard brief=" ">me-&gt;cnt-- == 0</guard>
       <choice_glyph conn="23,33,5,3,-11,-17,4">
        <action box="-4,-2,4,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="33,33,1,-1,-10">
       <action box="-8,-2,13,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TACHO">
      <action>static uint32_t tachoLPS = 0U; /* Low-Pass-Filtered tacho reading */

me-&gt;cnt = 1;

uint32_t tmp = Q_PAR(me);    //get tacho reading

/* 1st order low-pass filter: time constant ~= 2^n samples
* TF = (1/2^n)/(z-((2^n - 1)/2^n)),
* eg, n=3, y(k+1) = y(k) - y(k)/8 + x(k)/8 =&gt; y += (x - y)/8
* - borrowed from M.Samek */
tachoLPS += (((int)tmp - (int)tachoLPS + 4) &gt;&gt; 8);       /* Low-Pass-Filter */

QACTIVE_POST_X((QActive*)&amp;AO_Console, 1, RPM_SIG,
    tachoLPS);    //send out RPM</action>
      <tran_glyph conn="33,29,1,-1,-8">
       <action box="-6,-2,6,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="16,23,17,12"/>
    </state>
    <state_diagram size="50,48"/>
   </statechart>
  </class>
  <class name="Blinke" superclass="qpn::QMsm">
   <documentation>ACHTUNG!
ALLES TURISTEN UND NONTEKNISCHEN LOOKENPEEPERS!
DAS KOMPUTERMASCHINE IST NICHT FÜR DER GEFINGERPOKEN UND MITTENGRABEN! ODERWISE IST EASY TO SCHNAPPEN DER SPRINGENWERK, BLOWENFUSEN UND POPPENCORKEN MIT SPITZENSPARKEN.
IST NICHT FÜR GEWERKEN BEI DUMMKOPFEN. DER RUBBERNECKEN SIGHTSEEREN KEEPEN DAS COTTONPICKEN HÄNDER IN DAS POCKETS MUSS.
ZO RELAXEN UND WATSCHEN DER BLINKENLICHTEN.

For more information refer to https://en.wikipedia.org/wiki/Blinkenlights</documentation>
   <attribute name="cnt" type="uint16_t" visibility="0x02" properties="0x01">
    <documentation>counter used in LED timing</documentation>
   </attribute>
   <attribute name="on_time" type="uint8_t" visibility="0x02" properties="0x01"/>
   <attribute name="off_time" type="uint16_t" visibility="0x02" properties="0x01"/>
   <statechart>
    <initial target="../1/3">
     <action>Blinke_on_time = RUN_ON_TIME;
Blinke_off_time = RUN_OFF_TIME;</action>
     <initial_glyph conn="30,21,4,0,5">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="DER_BLINKENLICHT">
     <tran trig="ALARM" target="../3">
      <action>Blinke_on_time = ALARM_ON_TIME;
Blinke_off_time = ALARM_OFF_TIME;</action>
      <tran_glyph conn="21,30,3,3,7">
       <action box="0,-2,7,2"/>
      </tran_glyph>
     </tran>
     <tran trig="RUN" target="../3">
      <action>Blinke_on_time = RUN_ON_TIME;
Blinke_off_time = RUN_OFF_TIME;</action>
      <tran_glyph conn="21,36,3,3,7">
       <action box="0,-2,6,2"/>
      </tran_glyph>
     </tran>
     <state name="Off">
      <tran trig="TICK">
       <action>Blinke_cnt--;</action>
       <choice target="../../../3">
        <guard>Blinke_cnt == 0</guard>
        <choice_glyph conn="49,36,5,1,-3">
         <action box="-10,-2,7,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="56,36,3,-1,-7">
        <action box="0,-2,7,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="56,26,18,14"/>
     </state>
     <state name="On">
      <entry brief="LED On">LED_ON();
Blinke_cnt = Blinke_on_time;</entry>
      <exit brief="LED_OFF">LED_OFF();
Blinke_cnt = Blinke_off_time;</exit>
      <tran trig="TICK">
       <action>Blinke_cnt--;</action>
       <choice target="../../../2">
        <guard>Blinke_cnt == 0</guard>
        <choice_glyph conn="53,32,5,3,3">
         <action box="4,-2,6,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="46,32,1,-1,7">
        <action box="0,-2,7,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="28,26,18,14">
       <entry box="1,2,9,2"/>
       <exit box="1,4,9,2"/>
      </state_glyph>
     </state>
     <state_glyph node="21,22,54,19"/>
    </state>
    <state_diagram size="103,101"/>
   </statechart>
  </class>
  <attribute name="AO_Console" type="struct Console" visibility="0x00" properties="0x00"/>
  <operation name="Console_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Console *me = &amp;AO_Console;
QMActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Console_initial));

Console_Tacho_ctor(&amp;me-&gt;tacho);
QMSM_INIT((QMsm*)&amp;me-&gt;tacho);

Console_Blinke_ctor(&amp;me-&gt;blinke);
QMSM_INIT((QMsm*)&amp;me-&gt;blinke);

/* Initialize console hardware */

       U1MODE = 0x0008;                                /* enable high baud rate */
       U1STAbits.UTXISEL1 = 1;
       U1BRG  = ((FCY / 4 / BAUD_RATE_CONSOLE) - 1);    /* baud rate generator */

       _U1TXIP = 1; //serial interrupt priority
       _U1RXIP = 1;
       _U1ERIP = 1;
       U1MODEbits.UARTEN = 1;    //UART then Tx - in that order!
       U1STAbits.UTXEN   = 1;

{    uint8_t tmpdata;
       tmpdata = U1RXREG;       //clear RX errors
}
       U1STAbits.FERR = 0;
       U1STAbits.OERR = 0;

       CONSOLE_RX_TRIS = 1;    //set RX to input. todo - make less hardcoded

       consoleTail = 0;
       consoleHead = 0;

        //do not enable interrupts here - do it in QF_onStartup()
        _U1RXIF = 0;
        _U1ERIF = 0;
        </code>
  </operation>
 </package>
 <package name="BSP" stereotype="0x02">
  <package name="ISR" stereotype="0x02">
   <operation name="_AddressError" type="void __attribute__((__interrupt__,__no_auto_psv__))" visibility="0x00" properties="0x00">
    <code>while(1);    //Address error</code>
   </operation>
   <operation name="_StackError" type="void __attribute__((__interrupt__,__no_auto_psv__))" visibility="0x00" properties="0x00">
    <code>while(1);</code>
   </operation>
   <operation name="_T1Interrupt" type="void __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <documentation>QPN Tick generator</documentation>
    <code>//typedef struct but_t {    //button debouncing 


static uint32_t btn_debounced  = 0U;
static uint8_t  debounce_state = 0U;

//static uint32_t rbut_debounced  = 0U;
//static uint8_t  rbut_debounce_state = 0U;

//static uint32_t bbut_debounced  = 0U;
//static uint8_t  bbut_debounce_state = 0U;

uint8_t btn = RBUT_PIN;          /* read the push button state */
    switch (debounce_state) {
        case 0:
            if (btn != btn_debounced) {
                debounce_state = 1;         /* transition to the next state */
            }
            break;
        case 1:
            if (btn != btn_debounced) {
                debounce_state = 2;         /* transition to the next state */
            }
            else {
                debounce_state = 0;           /* transition back to state 0 */
            }
            break;
        case 2:
            if (btn != btn_debounced) {
                debounce_state = 3;         /* transition to the next state */
            }
            else {
                debounce_state = 0;           /* transition back to state 0 */
            }
            break;
        case 3:
            if (btn != btn_debounced) {
                btn_debounced = btn;     /* save the debounced button value */

                if (btn == 0) {                 /* is the button depressed? */
                    QACTIVE_POST_X_ISR((QActive *)&amp;AO_Console, 1,
                        RBUT_PRESS_SIG, 0);
                }
                else {
                    QACTIVE_POST_X_ISR((QActive *)&amp;AO_Console, 1,
                        RBUT_RELEASE_SIG, 0);
                }

            }
            debounce_state = 0;               /* transition back to state 0 */
            break;
    }

_T1IF = 0;                              /* clear Timer 1 interrupt flag */

QACTIVE_POST_X_ISR((QActive*)&amp;AO_Console, 1,
    TICK_SIG, 0U);

QF_tickISR();                /* handle all armed time events in QF-nano */</code>
   </operation>
   <operation name="_U1RXInterrupt" type="void  __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <code>uint8_t tmpdata;
while( U1STAbits.URXDA == 1 ) {      
    tmpdata = U1RXREG;            
    QACTIVE_POST_X_ISR
        ((QActive*)&amp;AO_Console, 1, KBD_KEY_SIG, tmpdata);
}
_U1RXIF = 0;
//Input can be paced by disabling interrupt here
// and re-enabling in &amp;Console</code>
   </operation>
   <operation name="_U1TXInterrupt" type="void  __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <documentation>UART1 transmit ISR</documentation>
    <code>static const char* pPrintStr = 0; //stores a string being printed

while( U1STAbits.UTXBF == 0 ) {    //UART buffer available
    if( *pPrintStr ) {             //previous string not completed
        U1TXREG = *pPrintStr++;
    }//if( *pPrintStr...
    else {                         //get next string
        if( consoleHead != consoleTail ) {    //data available
            consoleTail++;
#if CONSOLE_BUFMASK &lt; 255
            consoleTail &amp;= CONSOLE_BUFMASK;
#endif //CONSOLE_TX_BUFMASK &lt; 255

             pPrintStr = consoleBuf[consoleTail];
        }
        else {              //queue empty
            _U1TXIE = 0;    //disable interrupt
            return;    //IF not cleared - bug?
         }
    }//else - get next string
}//while( U2STAbits.UTXBF == 0...

_U1TXIF = 0;    //clear interrupt</code>
   </operation>
   <operation name="_U1ErrInterrupt" type="void  __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <code>_U1ERIF = 0;</code>
   </operation>
  </package>
  <package name="QPn" stereotype="0x02">
   <operation name="QF_onStartup" type="void" visibility="0x00" properties="0x00">
    <code>T1CON = 0x0000U;  /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1 */
TMR1  = 0x0000U; /* Start counting from 0 and clear the prescaler count */
PR1   = (uint16_t)((FCY_HZ / BSP_TICKS_PER_SEC) - 1.0 + 0.5); /* period */
_T1IP = TIMER1_ISR_PRIO;              /* set Timer 2 interrupt priority */
_T1IF = 0;                           /* clear the interrupt for Timer 1 */
_T1IE = 1;                              /* enable interrupt for Timer 1 */
T1CONbits.TON = 1;                                     /* start Timer 1 */

/* Enable peripheral interrupts as late as possible */
_CCT3IE = 1;    //tacho timer
_CCP3IE = 1;    //tacho capture
_U1RXIE = 1;                                     /* Console on UART1 Rx */
_NVMIE = 1;            //EEPROM</code>
   </operation>
   <operation name="QF_onIdle" type="void" visibility="0x00" properties="0x00">
    <documentation>/*****************************************************************************
* NOTE01:
* The callback function QF_onIdle() is called with interrupts disabled,
* because the idle condition can be invalidated by any enabled interrupt
* that would post events. The QF_onIdle() function *must* enable interrupts
* internally
*
* NOTE02:
* To be on the safe side, the DISICNT counter is set to just 1 cycle just
* before entering the Idle mode (or Sleep mode, if you choose). This way,
* interrupts (with priorities 1-6) get enabled at the same time as the
* transition to the low-power mode.
*/</documentation>
    <code>//LED_ON ();
//LED_OFF();

#ifdef NDEBUG
    __asm__ volatile(&quot;disi #0x0001&quot;);
    Idle();                          /* transition to Idle mode, see NOTE02 */
#else
    QF_INT_ENABLE();                       /* enable interrupts, see NOTE01 */
#endif</code>
   </operation>
   <operation name="Q_onAssert" type="void" visibility="0x00" properties="0x00">
    <parameter name="file" type="char const Q_ROM * const Q_ROM_VAR"/>
    <parameter name="line" type="int"/>
    <code>(void)file;                                   /* avoid compiler warning */
(void)line;                                   /* avoid compiler warning */
QF_INT_DISABLE();             /* make sure that interrupts are disabled */
for (;;) {
}</code>
   </operation>
  </package>
  <package name="A4960" stereotype="0x02">
   <package name="Common" stereotype="0x02">
    <operation name="SPI_init" type="void" visibility="0x02" properties="0x00">
     <documentation>mode 0: CKP = 0; CKE = 1;
SPI1 used</documentation>
     <code>SSP1STATbits.CKE = 1;
SSP1CON1bits.SSPM = 0b1010;
SSP1ADD = 0x0f;    //1 MHz SPI clock
SSP1CON1bits.SSPEN = 1; //enable SPI
MISO_TRIS = 1;    //set MISO line to input</code>
    </operation>
    <operation name="A4960_xfer" type="uint16_t" visibility="0x00" properties="0x00">
     <documentation>read/write A4960 config register. May utilize PIC MSSP-specific double-buffering</documentation>
     <parameter name="reg" type="uint8_t"/>
     <parameter name="data" type="uint16_t"/>
     <code>A4960_CS_PIN = 0;

uint16_t tmpdata;

SSP1BUF = ((reg &lt;&lt; 4) | (data &gt;&gt; 8));    //send upper byte
while(SSP1STATbits.BF == 0);    //wait till end of xfer

tmpdata = SSP1BUF;

if(tmpdata &amp; 0x80) {    //A4960 fault
    QACTIVE_POST_X((QActive*)&amp;AO_Console, 1, FF_SIG,0U);
};

SSP1BUF = data &amp; 0xff;        //send lower byte

tmpdata = tmpdata &lt;&lt; 8;
while(SSP1STATbits.BF == 0);    //wait till end of xfer

tmpdata = (tmpdata | SSP1BUF);

A4960_CS_PIN = 1;

/* Look out for events */

if(SSP1CON1bits.WCOL == 1) {    //write collision
    SSP1CON1bits.WCOL = 0;        //clear
    QACTIVE_POST_X((QActive*)&amp;AO_Console, 1, WCOL_SIG,0U);
}

return tmpdata;</code>
    </operation>
    <operation name="getField" type="uint16_t" visibility="0x00" properties="0x00">
     <documentation>get contents of a 'reg' and extracts field defined by 'mask'</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>uint16_t tmpdata = A4960_xfer(field-&gt;reg,0U);
uint16_t tmpmask = field-&gt;mask;

tmpdata &amp;= tmpmask;    //clear the rest

while((tmpmask &amp; 0x01) == 0) {    //LSB equals 0
    tmpmask &gt;&gt;= 1;
    tmpdata &gt;&gt;= 1;
};

return(tmpdata);</code>
    </operation>
    <operation name="setField" type="uint16_t" visibility="0x00" properties="0x00">
     <documentation>'val' sets content of the field defined by 'reg', 'mask'</documentation>
     <parameter name="val" type="uint16_t"/>
     <parameter name="field" type="FIELD*"/>
     <code>uint16_t tmpdata = A4960_xfer(field-&gt;reg,0U);
uint16_t tmpmask = field-&gt;mask;
uint16_t tmpval = val;

tmpdata &amp;= ~tmpmask; //clear the field position

while((tmpmask &amp; 0x1) == 0) { //LSB equals 0
    tmpmask &gt;&gt;= 1;
    tmpval &lt;&lt;= 1;
}

tmpdata |= tmpval;            //insert field

return(A4960_xfer(field-&gt;reg + 1, tmpdata));//write</code>
    </operation>
    <operation name="convPercent" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>converts contents to percent (x6.25)</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>return((getField(field) + 1)*625U);</code>
    </operation>
   </package>
   <package name="Limits" stereotype="0x02">
    <operation name="ConvCommBlankTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>Communication Blank Time converter</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>const uint16_t const blanktimes[] = {50U,100U,400U,1000U};

uint8_t tmpdata = getField(field);

return(blanktimes[tmpdata]);</code>
    </operation>
    <operation name="ConvBlankTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Blank Time</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>return(400U*getField(field));</code>
    </operation>
    <operation name="ConvDeadTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Config 0 DT field AKA Dead Time. DS p.26</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>uint16_t tmpdata = getField(field);

return((tmpdata &lt; 3) ? 100U : tmpdata*50U);</code>
    </operation>
    <operation name="ConvVdsThreshold" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Vds Threshold</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>return(25U*getField(field));</code>
    </operation>
   </package>
   <package name="Run" stereotype="0x02">
    <operation name="ConvFixedOffTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Commutation Blank Time,DS p.27</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>return(10+(getField(field)*16U));</code>
    </operation>
    <operation name="ConvPhaseAdvance" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Phase Advance, x1000</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>return(getField(field)*1875U); //deg(e), DS p.28</code>
    </operation>
    <operation name="ConvBemfWindow" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of BEMF Window, x10</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>return(0x04 &lt;&lt; getField(field)); //us DS p.29</code>
    </operation>
   </package>
   <package name="Startup" stereotype="0x02">
    <operation name="ConvHoldTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Hold Time</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>return(getField(field)*8 + 2); //ms DS p.27</code>
    </operation>
    <operation name="ConvEndCommTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of End Commutation Time. 10x scale</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>return((getField(field) + 1)*2U); //ms, DS p.28</code>
    </operation>
    <operation name="ConvStartCommTime" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Start Commutation Time.</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>return((getField(field) + 1)*8U); //ms, DS p.28</code>
    </operation>
    <operation name="ConvRampRate" type="uint16_t" visibility="0x02" properties="0x00">
     <documentation>returns value of Ramp Rate, x1000</documentation>
     <parameter name="field" type="FIELD*"/>
     <code>return((getField(field) + 1)*2U); //ms, DS p.28</code>
    </operation>
   </package>
  </package>
  <package name="PWM" stereotype="0x02">
   <operation name="PWM_init" type="void" visibility="0x02" properties="0x00">
    <documentation>OC5</documentation>
    <code>CCP5CON1Lbits.CCSEL = 0;    //mode
CCP5CON1Lbits.MOD = 0b0101;

CCP5CON1Lbits.TMR32 = 0;    //timebase
CCP5CON1Lbits.TMRSYNC = 0;
CCP5CON1Lbits.CLKSEL = 0b000;
CCP5CON1Lbits.TMRPS = 0b00;
CCP5CON1Hbits.TRIGEN = 0;
CCP5CON1Hbits.SYNC = 0b00000;

CCP5CON2Hbits.OCAEN = 1;    //enable PWM on the output
//CCP5CON3Hbits.OUTM = 0b000;
//CCP5CON3Hbits.POLBDF = 0;    //active high
CCP5CON3Hbits.POLACE = 0;
CCP5TMRL = 0x0000;
CCP5PRL = 3200U;
CCP5RA = 0x000;
CCP5RB = 0x001ff;
CCP5CON1Lbits.CCPON = 1;</code>
   </operation>
   <operation name="PWM_idxLookup" type="uint8_t" visibility="0x02" properties="0x00">
    <documentation>returns index of array element containing 'val'. 8 element array 
hardcoded</documentation>
    <parameter name="array" type="const uint16_t*"/>
    <parameter name="val" type="uint16_t"/>
    <code>uint8_t i = 0;

while( i &lt; 8 ) {
    if(array[i] == val) {
        return(i);
    }
    i++;
}

return(0xff); //not found</code>
   </operation>
   <operation name="PWM_getPeriodIdx" type="uint16_t" visibility="0x02" properties="0x00">
    <documentation>dummy parameter to conform to a funcptr.</documentation>
    <parameter name="item" type="ITEM*"/>
    <code>return(PWM_idxLookup(pwmPeriod,CCP5PRL));</code>
   </operation>
   <operation name="PWM_setPeriod" type="uint16_t" visibility="0x02" properties="0x00">
    <parameter name="val" type="uint16_t"/>
    <parameter name="item" type="ITEM*"/>
    <code>return(CCP5PRL = pwmPeriod[val]);</code>
   </operation>
   <operation name="PWM_getDuty" type="uint16_t" visibility="0x02" properties="0x00">
    <parameter name="item" type="ITEM*"/>
    <code>return(0);</code>
   </operation>
   <operation name="PWM_setDuty" type="uint16_t" visibility="0x02" properties="0x00">
    <parameter name="val" type="uint16_t"/>
    <parameter name="item" type="ITEM*"/>
    <code>return(0);</code>
   </operation>
   <operation name="PWM_convFreq" type="uint16_t" visibility="0x02" properties="0x00">
    <documentation>returns interger of a frequency. Hardcoded</documentation>
    <parameter name="item" type="ITEM*"/>
    <code>return(pwmFreq[PWM_getPeriodIdx(item)]);</code>
   </operation>
  </package>
  <package name="Tacho" stereotype="0x02">
   <operation name="Tacho_init" type="void" visibility="0x02" properties="0x00">
    <documentation>IC3 on tacho</documentation>
    <code>CCP3CON1Lbits.CCPON = 0;   //disable
CCP3CON1Lbits.CCSEL = 1;   //input capture mode
CCP3CON1Lbits.CLKSEL = 0;  //sysclk
CCP3CON1Lbits.TMR32 = 0;   //32-bit mode
CCP3CON1Lbits.MOD = 1;     //rising every rising edge
CCP3CON2Hbits.ICSEL = 0;   //rising edge
CCP3CON1Hbits.IOPS = 0;    //interrupt on every event
CCP3CON1Lbits.TMRPS = 0;   //prescaler
CCP3CON1Lbits.CCPON = 1;   //enable

_CCT3IP = 1;    //tacho timer interrupt priority
                //must be lower than tacho capture
_CCP3IP = 6;    //tacho capture interrupt priority</code>
   </operation>
   <operation name="_CCT3Interrupt" type="void __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <documentation>Tachometer timer overflow interrupt </documentation>
    <code>tach_ro++;
_CCT3IF = 0;</code>
   </operation>
   <operation name="_CCP3Interrupt" type="void __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <documentation>measuring TACHO output from A4960</documentation>
    <code>static uint16_t oldval = 0;
uint16_t tmpdata = 0;
uint16_t tmp2 = 0;

while(CCP3STATLbits.ICBNE) {    //data present
    tmpdata = CCP3BUFL;
}

tmp2 = tmpdata;
tmpdata += oldval;
oldval = ~tmp2;

//tmpdata |= (uint32_t)tach_ro &lt;&lt; 16;

QACTIVE_POST_X_ISR ((QActive*)&amp;AO_Console, 1,
TACHO_SIG, tmpdata);

//tach_ro = 0;

_CCP3IF = 0;</code>
   </operation>
  </package>
  <package name="HEE" stereotype="0x00">
   <operation name="_NVMInterrupt" type="void __attribute__((__interrupt__, auto_psv))" visibility="0x00" properties="0x00">
    <documentation>Interrupt on end of EEPROM modification operation</documentation>
    <code>if( heeq_Head != heeq_Tail ) {    //data available
            heeq_Tail++;
#if HEEQ_BUFMASK &lt; 255
            heeq_Tail &amp;= HEEQ_BUFMASK;
#endif

// __ builtin_software_breakpoint();

    HEE_REQ req = heeq[heeq_Tail];

//_prog_addressT p = req.addr;

    NVMCONbits.NVMOP = req.addr;
//    TBLPAG = __builtin_tblpage(p);
//    uint16_t offset = __builtin_tbloffset(&amp;p);

    if(req.op == EE_WRITE) {
        // Write Data Value To Holding Latch
//        __builtin_tblwtl(offset, req.data);
    }
    else {
//        __builtin_tblwtl(offset, offset);
    }
    // Disable Interrupts For 5 Instructions
    asm volatile (&quot;disi #5&quot;);
    // Issue Unlock Sequence &amp; Start Write Cycle
    __builtin_write_NVM();
}
else { //queue empty
    _NVMIE = 0;
}

_NVMIF = 0;</code>
   </operation>
   <operation name="HEE_init" type="void" visibility="0x02" properties="0x00">
    <code>NVMCONbits.PGMONLY = 1;
_NVMIP = 1;    //priority</code>
   </operation>
   <operation name="HEE_send" type="void" visibility="0x02" properties="0x00">
    <documentation>places EE request into request queue.</documentation>
    <parameter name="addr" type="_prog_addressT"/>
    <parameter name="op" type="uint8_t"/>
    <parameter name="data" type="uint16_t"/>
    <code>HEE_REQ req;

req-&gt;addr = addr;
req-&gt;op = op;
req-&gt;data = data;

uint8_t tmphead = heeq_Head + 1;

#if HEEQ_BUFMASK &lt; 255
tmphead &amp;= HEEQ_BUFMASK;
#endif

while(tmphead == heeq_Tail) {}     //this line blocks!

heeq[tmphead] = req;
heeq_Head = tmphead;

if(_NVMIE == 0) {    //trigger interrupt
    _NVMIF = 1;
    _NVMIE = 1;
}

return;</code>
   </operation>
   <operation name="EEwr" type="_prog_addressT" visibility="0x00" properties="0x00">
    <documentation>writes one EE variable. Returns EEDATA address where var is actually written.</documentation>
    <parameter name="id" type="uint8_t"/>
    <parameter name="val" type="uint8_t"/>
    <code>uint8_t i;

if(id &gt;= HEE_PAGESIZE ) {    //range check
    return(0);
}

/* get current page */

for(i = 0; i &lt; HEE_PAGES &amp;&amp; (heep[i][0] &amp; 0x8000); i++ ) {}

if(i == HEE_PAGES) {    //no current page
    while(1);    //todo: handle
}
else {    //find first vacant location
    </code>
   </operation>
  </package>
  <operation name="BSP_init" type="void" visibility="0x00" properties="0x00">
   <code>RCONbits.SWDTEN = 0; /* disable Watchdog */

TRISA = 0x00;        /* set all pins as dig.outputs */
PORTA = 0x00;                               
TRISB = 0x00;
PORTB = 0x00;
ANSA = 0x00;
ANSB = 0x00;

CONS_RX_TRIS = 1;    //inputs
TACHO_TRIS = 1;    
DIAG_TRIS = 1;     
RBUT_TRIS = 1;    
BBUT_TRIS = 1;    
EBUT_TRIS = 1;
ENCA_TRIS = 1;
ENCB_TRIS = 1;    

SPI_init();
PWM_init();
Tacho_init();
HEE_init();
</code>
  </operation>
 </package>
 <directory name=".">
  <file name="bsp.h">
   <text>#ifndef bsp_h
#define bsp_h

#include &lt;xc.h&gt;

#define FOSC_HZ                 32000000.0    /* clock */
                                       /* instruction cycle clock frequency */
#define FCY_HZ                  (FOSC_HZ / 2.0)

#define FCY FCY_HZ

                                               /* the system tick rate [Hz] */
#define BSP_TICKS_PER_SEC    100UL

                                /* controlling the LED */
//LED on RB15
#define LED_ON()                LATBbits.LATB15 = 0
#define LED_OFF()               LATBbits.LATB15 = 1

/* A4960 constants */
#define A4960_CONF0_RD 0
#define A4960_CONF0_WR 1
#define A4960_CONF1_RD 2
#define A4960_CONF1_WR 3
#define A4960_CONF2_RD 4
#define A4960_CONF2_WR 5
#define A4960_CONF3_RD 6
#define A4960_CONF3_WR 7
#define A4960_CONF4_RD 8
#define A4960_CONF4_WR 9
#define A4960_CONF5_RD 0x0a
#define A4960_CONF5_WR 0x0b
#define A4960_MASK_RD 0x0c
#define A4960_MASK_WR 0x0d  
#define A4960_RUN_RD 0x0e
#define A4960_RUN_WR 0x0f

#ifdef UNDEF

typedef struct __attribute__((__packed__)) tagConfig0 {
    union {
        uint16_t val;
        struct {
            unsigned dt:6;
            unsigned bt:4;
            unsigned cb:2;            
            unsigned reg:4;            
        };
    };
} A4960_CONFIG0;
        
typedef struct __attribute__((__packed__)) tagConfig1 {
    union {
        uint16_t val;
        struct {
            unsigned vt:6;
            unsigned vr:4;
            unsigned :2;
            unsigned reg:4;
        };
    };
} A4960_CONFIG1;

typedef struct __attribute__((__packed__)) tagConfig2 {
    union {
        uint16_t val;
        struct {
            unsigned pt:5;
            unsigned :7;
            unsigned reg:4;
        };
    };
} A4960_CONFIG2;

typedef struct __attribute__((__packed__)) tagConfig3 {
    union {
        uint16_t val;
        struct {
            unsigned ht:4;
            unsigned hq:4;
            unsigned ids:1;
            unsigned :3;
            unsigned reg:4;
        };
    };
} A4960_CONFIG3;

typedef struct __attribute__((__packed__)) tagConfig4 {
    union {
        uint16_t val;
        struct {
            unsigned sc:4;
            unsigned ec:4;
            unsigned :4;
            unsigned reg:4;
        };
    };
} A4960_CONFIG4;

typedef struct __attribute__((__packed__)) tagConfig5 {
    union {
        uint16_t val;
        struct {
            unsigned rr:4;
            unsigned rq:4;
            unsigned pa:4;
            unsigned reg:4;
        };
    };
} A4960_CONFIG5;

typedef struct __attribute__((__packed__)) tagMask {
    union {
        uint16_t val;
        struct {
            unsigned cl:1;
            unsigned ch:1;
            unsigned bl:1;
            unsigned bh:1;
            unsigned al:1;
            unsigned ah:1;
            unsigned vc:1;
            unsigned vb:1;
            unsigned va:1;
            unsigned los:1;
            unsigned ts:1;
            unsigned tw:1;
            unsigned reg:4;
        };
    };
} A4960_MASK;

typedef struct __attribute__((__packed__)) tagRun {
    union {
        uint16_t val;
        struct {
            unsigned run:1;
            unsigned dir:1;
            unsigned brk:1;
            unsigned rsc:1;
            unsigned dg:2;
            unsigned esf:1;
            unsigned bw:3;
            unsigned bh:2;
            unsigned reg:4;
        };
    };
} A4960_RUN;

#define A4960_DIAGNOSTIC A4960_MASK

#endif    //UNDEF


/* Menu item definition */
typedef struct item_t {                //item structure
    const char* const name;
    const char* const unit;
    uint8_t point;
    uint8_t reg;
    uint16_t mask;
    uint16_t(*get)(struct item_t*);
    uint16_t(*set)(uint16_t, struct item_t*);
    uint16_t(*conv)(struct item_t*);
} ITEM;

/* Config field definition format */
typedef struct field_t {                
    const char* const title;            //what is printed on the screen        
    const char* const unit;             //unit of measurement
    uint8_t point;                      //decimal point
    uint8_t reg;                        //register
    uint16_t mask;                      //field mask 
    uint16_t(*conv)(struct field_t*);    //conversion utility
} FIELD;



void BSP_init(void);

//uint16_t getField( FIELD* field );                  //get A4960 field
//uint16_t setField( uint16_t val, FIELD* field );    //set A4960 field
$declare(BSP::A4960::Common::A4960_xfer)
$declare(BSP::A4960::Common::getField)
$declare(BSP::A4960::Common::setField)

#endif                                                             /* bsp_h */</text>
  </file>
  <file name="icbm.c">
   <text>/* Allegro A4960 BLDC test fixture main file */

#include &quot;qpn_port.h&quot;                                       /* QP-nano port */
#include &quot;bsp.h&quot;                             /* Board Support Package (BSP) */
#include &quot;icbm.h&quot;                            /* application interface */

/*..........................................................................*/
static QEvt l_consoleQueue[10];

/* QF_active[] array defines all active object control blocks --------------*/
QActiveCB const Q_ROM QF_active[] = {
    { (QActive *)0,           (QEvt *)0,      0U                    },
    { (QActive *)&amp;AO_Console,  l_consoleQueue,  Q_DIM(l_consoleQueue)  }
};

/* make sure that the QF_active[] array matches QF_MAX_ACTIVE in qpn_port.h */
//Q_ASSERT_COMPILE(QF_MAX_ACTIVE == Q_DIM(QF_active) - 1);

/*..........................................................................*/
int_t main () {

    BSP_init();                                     /* initialize the board */

    Console_ctor();

    return QF_run();                         /* transfer control to QF-nano */
}</text>
  </file>
  <file name="bsp.c">
   <text>/* Allegro A4960 BLDC test fixture board support package */
#include &quot;qpn_port.h&quot;
#include &quot;bsp.h&quot;
#include &quot;icbm.h&quot;
#include &lt;libpic30.h&gt;
//rev0 notes
//1.console on UART1
//SPI1
//CS on pin 25
//ICD on different pins

/* PIC24FV16KM202-specific */

/* MCU configuration bits                      */
/* external 8 MHz crystal w/PLL, 32MHz clock   */
#pragma config BWRP=OFF, BSS=OFF, GWRP=OFF, GCP=OFF
#pragma config FNOSC = PRIPLL, SOSCSRC = DIG, LPRCSEL = LP, IESO = ON
#pragma config POSCMOD = HS, OSCIOFNC = CLKO, POSCFREQ = MS, FCKSM = CSECME
#pragma config FWDTEN = OFF, WINDIS = OFF
#pragma config BOREN=BOR0, RETCFG=OFF, PWRTEN = OFF, MCLRE=ON
//#pragma config ICS = PGx2
#pragma config ICS = PGx1

/* Local-scope objects -----------------------------------------------------*/
                             /* frequency of the oscillator for PIC24 */
#define FOSC_HZ                 32000000.0
                                       /* instruction cycle clock frequency */
#define FCY_HZ                  (FOSC_HZ / 2.0)



/* Peripherals                                -----------------------------*/
//pins that will eventually become inputs

#define CONS_RX_TRIS _TRISB2

//SPI1 used to talk to A4960
#define MISO_TRIS _TRISB10
//OC2B used to measure speed
#define TACHO_TRIS _TRISB12
#define DIAG_TRIS  _TRISB9

#define RBUT_TRIS _TRISB5    //RUN button
#define RBUT_PIN  _RB5

#define BBUT_TRIS _TRISA4    //BRAKE button
#define BBUT_PIN  _RA4

#define EBUT_TRIS _TRISB3    //Button on encoder shaft
#define EBUT_PIN  _RB3

//it pays to keep encoder channels together
#define ENCA_TRIS _TRISA0   //Encoder A channel
#define ENCA_PIN  _RA0

#define ENCB_TRIS _TRISA1    //Encoder B channel
#define ENCB_PIN  _RA1

/* High Endurance EEPROM        ------------------------------------------*/
#define EE_SIZE 256U                 //x16 bit
#define HEE_PAGES 4U                  //more than 2 to detect
                                     //failed pack
#define HEE_PAGESIZE EE_SIZE/HEE_PAGES

#define EE_ROW_SIZE 8U               //8 words erase max
#define EE_ROWS 8U

#define EE_ERASE_8    0x1a        
#define EE_ERASE_4    0x19
#define EE_ERASE_1    0x18
#define EE_ERASE_ALL  0x10  
#define EE_WRITE   0x04

//EEPROM Write queue size - must be power of 2
#define HEEQ_BUFSIZE 64
#define HEEQ_BUFMASK ( HEEQ_BUFSIZE - 1 )

#if ( HEEQ_BUFSIZE &amp; HEEQ_BUFMASK )
#error EEPROM Write queue size is not a power of 2
#endif

typedef union
{
    uint8_t val;
    struct
    {
        unsigned addrNotFound:1;        // Return 0xFFFF
        unsigned expiredPage:1;               // Return 0x1
        unsigned packBeforePageFull:1;    // Not a return condition
        unsigned packBeforeInit:1;        // Return 0x3
        unsigned packSkipped:1;            // Return 0x4
        unsigned IllegalAddress:1;        // Return 0x5
        unsigned pageCorrupt:1;            // Return 0x6
        unsigned writeError:1;            // Return 0x7
    };
} HEE_FLAGS;

typedef struct __attribute__((__packed__)) heep_t {    //page status 
    union {
        uint16_t val;
        struct {
            unsigned count:13;
            unsigned expired:1;
            unsigned available:1;
            unsigned current:1;
        };
    };
} HEE_PAGE_STATUS;

typedef struct heeq_t {    //EEPROM modification request
    uint16_t data;    
    _prog_addressT addr;
    uint8_t op;
} HEE_REQ;

//todo: check if zeroing it at programming is certain
__eds__ const uint16_t heep[4][64] __attribute__((space(eedata), aligned(2)));


//EEPROM WR Queue
HEE_REQ heeq[HEEQ_BUFSIZE];
uint8_t heeq_Head;
volatile uint8_t heeq_Tail;    //interrupt changes this

/* A4960 */

#define A4960_CS_PIN _RB14


#define TIMER1_ISR_PRIO         4

//- Const

//Enable-disable messages
const char const zen[] = &quot;\x08\x08\x08 0 - Enable, 1- Disable&quot;;

//Common units

const char const us[] = &quot;us&quot;;    //microseconds
const char const ms[] = &quot;ms&quot;;    //milliseconds
const char const pct[] = &quot;%&quot;;    //percent

//- Static

static uint8_t tach_ro;    //rollover count for Tacho 

/* ISRs --------------------------------------------------------------------*/
$define(BSP::ISR::_AddressError)
$define(BSP::ISR::_StackError)
$define(BSP::ISR::_T1Interrupt)

$define(BSP::Tacho::_CCT3Interrupt)
$define(BSP::Tacho::_CCP3Interrupt)

$define(BSP::HEE::_NVMInterrupt)

$define(BSP::A4960::Common::SPI_init)
$define(BSP::A4960::Common::A4960_xfer)
$define(BSP::A4960::Common::getField)
$define(BSP::A4960::Common::setField)

$define(BSP::A4960::Common::convPercent)
//- Limits
$define(BSP::A4960::Limits::ConvCommBlankTime)
$define(BSP::A4960::Limits::ConvBlankTime)
$define(BSP::A4960::Limits::ConvDeadTime)
//- Common ConvPercent used for Curr.Sense Ratio
$define(BSP::A4960::Limits::ConvVdsThreshold)

/* Item access structure. Layout as follows:

name - what is printed in the menu
unit - what is printed after the value
point - decimal point
reg - register containing the item
mask - bitmask of an item inside the register
conv - function to convert contents to value
*/

FIELD const CommBlankTime =
    {&quot;Commutation Blank Time&quot;, us, 0U, A4960_CONF0_RD, 0x0c00,
        &amp;ConvCommBlankTime};

FIELD const BlankTime = 
    {&quot;Blank Time&quot;,us, 3U, A4960_CONF0_RD, 0x03c0,
        &amp;ConvBlankTime};

FIELD const DeadTime = 
    {&quot;Dead Time&quot;,&quot;ns&quot;, 0U, A4960_CONF0_RD, 0x003f,
        &amp;ConvDeadTime};

FIELD const CurrentSenseRefRatio = 
    {&quot;Current Sense&quot;,pct, 2U, A4960_CONF1_RD, 0x03c0,
        &amp;convPercent};

FIELD const VdsThreshold = 
    {&quot;VDS Threshold&quot;,&quot;mV&quot;, 0U, A4960_CONF1_RD, 0x003f,
        &amp;ConvVdsThreshold};

//- Run
$define(BSP::A4960::Run::ConvFixedOffTime)
$define(BSP::A4960::Run::ConvPhaseAdvance)
//BemfHyst - get
$define(BSP::A4960::Run::ConvBemfWindow)
//Brake - get
//Direction - get
//Run - get


FIELD const FixedOffTime = 
    {&quot;Fixed Off Time&quot;,us, 1U, A4960_CONF2_RD, 0x001f, &amp;ConvFixedOffTime};

FIELD const PhaseAdvance = 
    {&quot;Phase Advance&quot;,&quot;deg(e)&quot;, 3U, A4960_CONF5_RD, 0x0c00, &amp;ConvPhaseAdvance};

FIELD const BemfHyst = 
    {&quot;BEMF Hysteresis&quot;,&quot;0 - Auto, 1 - None, 2 - High, 3 - Low&quot;, 0U, A4960_RUN_RD, 0x0c00,
        &amp;getField};

FIELD const BemfWindow = 
    {&quot;BEMF Window&quot;,us, 0U, A4960_RUN_RD, 0x0380, &amp;ConvBemfWindow};

FIELD const Brake = 
    {&quot;Brake&quot;,&quot;0 - Off, 1 - On&quot;, 0U, A4960_RUN_RD, 0x0004, &amp;getField};

FIELD const Direction = 
    {&quot;Direction&quot;,&quot;0 - Fwd, 1 - Rev&quot;, 0U, A4960_RUN_RD, 0x0002, &amp;getField};

FIELD const Run = 
    {&quot;Run&quot;,&quot;0 - Coast, 1 - Run&quot;, 0U, A4960_RUN_RD, 0x0001, &amp;getField};

//Startup

//HoldTorque - percent
$define(BSP::A4960::Startup::ConvHoldTime)
$define(BSP::A4960::Startup::ConvEndCommTime)
$define(BSP::A4960::Startup::ConvStartCommTime)
//ForcedCommTorque - A_ConvPercent
$define(BSP::A4960::Startup::ConvRampRate)

FIELD const HoldTorque = 
    {&quot;Hold Torque&quot;, pct, 2U, A4960_CONF3_RD, 0x00f0, &amp;convPercent};

FIELD const HoldTime = 
    {&quot;Hold Time&quot;,ms, 0U, A4960_CONF3_RD, 0x000f, &amp;ConvHoldTime};

FIELD const EndCommTime = 
    {&quot;End Comm. Time&quot;,ms, 0U, A4960_CONF4_RD, 0x00f0, &amp;ConvEndCommTime};

FIELD const StartCommTime = 
    {&quot;Start Comm. Time&quot;,ms, 0U, A4960_CONF4_RD, 0x000f, &amp;ConvStartCommTime};

FIELD const ForcedCommTorque = 
    {&quot;Forced Comm. Ramp-up Torque&quot;,pct, 2U, A4960_CONF5_RD, 0x00f0, &amp;convPercent};

FIELD const RampRate = 
    {&quot;Ramp Rate&quot;,ms, 1U, A4960_CONF5_RD, 0x000f, &amp;ConvRampRate};

//Flags - all generic

FIELD const VaFlag = 
    {&quot;Bootcap A Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0100, &amp;getField};

FIELD const VbFlag = 
    {&quot;Bootcap B Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0080, &amp;getField};

FIELD const VcFlag = 
    {&quot;Bootcap C Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0040, &amp;getField};

FIELD const AhFlag = 
    {&quot;Phase A High-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0020, &amp;getField};

FIELD const AlFlag = 
    {&quot;Phase A Low-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0010, &amp;getField};

FIELD const BhFlag = 
    {&quot;Phase B High-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0008, &amp;getField};

FIELD const BlFlag = 
    {&quot;Phase B Low-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0004, &amp;getField};

FIELD const ChFlag = 
    {&quot;Phase C High-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0002, &amp;getField};

FIELD const ClFlag = 
    {&quot;Phase C Low-Side Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0001, &amp;getField};

//- Misc all generic

FIELD const TorqueCtlMethod = 
    {&quot;Torque Control Method&quot;, &quot;0 - Current, 1 - Duty Cycle&quot;, 0U, A4960_CONF3_RD, 0x0100,
        &amp;getField};

FIELD const EnableStopOnFail = 
    {&quot;Stop on Fail&quot;, zen, 0U, A4960_RUN_RD, 0x0040, &amp;getField};

FIELD const DiagOutput = 
    {&quot;Diag Output&quot;,&quot;0 - Flt, 1 - LOS, 2 -VDS Thr, 3 - clock&quot;, 0U, A4960_RUN_RD, 0x0030,
        &amp;getField};

FIELD const RestartControl = 
    {&quot;Restart Control&quot;, zen, 0U, A4960_RUN_RD, 0x0080, &amp;getField};

FIELD const TwFlag = 
    {&quot;Temperature Warning Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0800,
        &amp;getField};

FIELD const TsFlag = 
    {&quot;Thermal Shutdown Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0400,
        &amp;getField};

FIELD const LosFlag = 
    {&quot;BEMF Sync. Loss Fault&quot;, zen, 0U, A4960_MASK_RD, 0x0200,
        &amp;getField};


//- PWM access

//One of the 8 pre-determined frequencies

static const uint16_t pwmPeriod[] = { 64000U, 32000U, 16000U,
    8000U, 3200U, 1600U, 800U, 320U };

static const uint16_t pwmFreq[] = { 250U, 500U, 1000U,
    2000U, 5000U, 10000U, 20000U, 50000U };

$define(BSP::PWM::PWM_init)
$define(BSP::PWM::PWM_idxLookup)
$define(BSP::PWM::PWM_getPeriodIdx)

$define(BSP::PWM::PWM_setPeriod)
$define(BSP::PWM::PWM_convFreq)
$define(BSP::PWM::PWM_getDuty)
$define(BSP::PWM::PWM_setDuty)

ITEM const PWM_Freq =
    {&quot;PWM Frequency&quot;, &quot;kHz&quot;, 3U, 0U, 0x07,
        &amp;PWM_getPeriodIdx, &amp;PWM_setPeriod, &amp;PWM_convFreq};

ITEM const PWM_Duty =
    {&quot;PWM Duty Cycle&quot;, &quot;%&quot;, 0U, 0U, 0x00,
        &amp;PWM_getDuty, &amp;PWM_setDuty, &amp;PWM_getDuty};


$define(BSP::HEE::HEE_init)

$define(BSP::Tacho::Tacho_init)
$define (BSP::BSP_init)
$define(BSP::QPn::QF_onStartup)
$define(BSP::QPn::QF_onIdle)
$define(BSP::QPn::Q_onAssert)
</text>
  </file>
  <file name="console.c">
   <text>/* Interactive Controller for Brushless Motors serial console AO */
#include &quot;qpn_port.h&quot;
#include &quot;icbm.h&quot;
#include &quot;bsp.h&quot;
#include &quot;libpic30.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

// A4960

//- Access to 'Limits' fields
extern FIELD const CommBlankTime;
extern FIELD const BlankTime;
extern FIELD const DeadTime;
extern FIELD const CurrentSenseRefRatio;
extern FIELD const VdsThreshold;

#ifdef UNDEF

//- Access to 'Limits' fields
extern ITEM const A4960_CommBlankTime;
extern ITEM const A4960_BlankTime;
extern ITEM const A4960_DeadTime;
extern ITEM const A4960_CurrentSenseRefRatio;
extern ITEM const A4960_VdsThreshold;

#endif

//- Access to 'Run' fields
extern FIELD const FixedOffTime;
extern FIELD const PhaseAdvance;
extern FIELD const BemfHyst;
extern FIELD const BemfWindow;
extern FIELD const Brake;
extern FIELD const Direction;
extern FIELD const Run;

//- Access to 'Startup' fields
extern FIELD const HoldTorque;
extern FIELD const HoldTime;
extern FIELD const EndCommTime;
extern FIELD const StartCommTime;
extern FIELD const ForcedCommTorque;
extern FIELD const RampRate;

//- Access to 'Flags' fields
extern FIELD const VaFlag;
extern FIELD const VbFlag;
extern FIELD const VcFlag;
extern FIELD const AhFlag;
extern FIELD const AlFlag;
extern FIELD const BhFlag;
extern FIELD const BlFlag;
extern FIELD const ChFlag;
extern FIELD const ClFlag;

//- Access to 'Misc' fields
extern FIELD const TorqueCtlMethod;
extern FIELD const EnableStopOnFail;
extern FIELD const DiagOutput;
extern FIELD const RestartControl;
extern FIELD const TwFlag;
extern FIELD const TsFlag;
extern FIELD const LosFlag;

//- Access to PWM
extern ITEM const PWM_Freq;
extern ITEM const PWM_Duty;

#define BAUD_RATE_CONSOLE 115200UL
//Console TX buffer size - must be power of 2
#define CONSOLE_BUFSIZE 64
#define CONSOLE_BUFMASK ( CONSOLE_BUFSIZE - 1 )

#if ( CONSOLE_BUFSIZE &amp; CONSOLE_BUFMASK )
#error Serial Tx Buffer size is not a power of 2
#endif

//#define CONSOLE_RX_PIN _RB2
#define CONSOLE_RX_TRIS _TRISB2

#define ROLL_TOUT BSP_TICKS_PER_SEC/10   //whirling star animation
#define STAT_TOUT BSP_TICKS_PER_SEC/5    //status line update rate


//LED times
#define RUN_ON_TIME  BSP_TICKS_PER_SEC/50
#define RUN_OFF_TIME BSP_TICKS_PER_SEC*3

#define ALARM_ON_TIME  BSP_TICKS_PER_SEC/20
#define ALARM_OFF_TIME BSP_TICKS_PER_SEC/20

/* Variables */
//Serial console
const char* consoleBuf[CONSOLE_BUFSIZE];
uint8_t consoleHead;
volatile uint8_t consoleTail;    //interrupt changes this

static const char* const crlf = &quot;\r\n&quot;;
static const char* const space = &quot; &quot;;

/*-- Main Menu */
const char* menuMain[] = 
    { &quot;Setup&quot;, &quot;Mess&quot;, &quot;Tune&quot; };
#define MENU_MAIN_CNT Q_DIM(menuMain)

/*-- Setup Menu and accompanying menu item arrays */
const char* const menuSetup[] = 
    { &quot;Startup&quot;, &quot;Ui&quot; };
#define MENU_SETUP_CNT Q_DIM(menuSetup)

const ITEM* const controlItems[] = {&amp;PWM_Freq};
#define CONTROL_CNT Q_DIM(controlItems)

const ITEM* const uiItems[] = {};
#define UI_CNT Q_DIM(uiItems)

/*- Mess Menu and accompanying menu item arrays */
const char* const menuMess[] = {&quot;Limits&quot;,&quot;Run&quot;,&quot;Startup&quot;,&quot;Flags&quot;,&quot;Misc&quot;};
#define MENU_MESS_CNT Q_DIM(menuMess)

const FIELD* const limitsFields[] = {&amp;CommBlankTime,&amp;BlankTime,&amp;DeadTime,
    &amp;CurrentSenseRefRatio, &amp;VdsThreshold};
#define LIMITS_CNT Q_DIM(limitsFields)

const FIELD* const runFields[] = {&amp;FixedOffTime, &amp;PhaseAdvance, &amp;BemfHyst,
     &amp;BemfWindow, &amp;Brake, &amp;Direction, &amp;Run};
#define RUN_CNT Q_DIM(runFields)



#ifdef UNDEF

const ITEM* const runItems[] =
    {&amp;A4960_FixedOffTime, &amp;A4960_PhaseAdvance, &amp;A4960_BemfHyst,
     &amp;A4960_BemfWindow, &amp;A4960_Brake, &amp;A4960_Direction, &amp;A4960_Run};
#define RUN_CNT Q_DIM(runItems)

#endif

const FIELD* const startupFields[] =
    {&amp;HoldTorque, &amp;HoldTime, &amp;EndCommTime,
     &amp;StartCommTime, &amp;ForcedCommTorque, &amp;RampRate};
#define STARTUP_CNT Q_DIM(startupFields)

const FIELD* const flagsFields[] = 
    {&amp;VaFlag, &amp;VbFlag, &amp;VcFlag, &amp;AhFlag,
     &amp;AlFlag, &amp;BhFlag, &amp;BlFlag, &amp;ChFlag,
     &amp;ClFlag};
#define FLAGS_CNT Q_DIM(flagsFields)

const FIELD* const miscFields[] =
    {&amp;TorqueCtlMethod, &amp;EnableStopOnFail, &amp;DiagOutput,
     &amp;RestartControl, &amp;TwFlag, &amp;TsFlag, &amp;LosFlag};
#define MISC_CNT Q_DIM(miscFields)

const char* const menuTune[]={&quot;Tune&quot;,&quot;Tune&quot;};
#define MENU_TUNE_CNT Q_DIM(menuTune)

/* local objects -----------------------------------------------------------*/
$declare(AOs::Tacho)
$declare(AOs::Blinke)
$declare(AOs::Console)

/* global objects ----------------------------------------------------------*/
Console AO_Console;

/* Active object definition ================================================*/
$define(AOs::Console_ctor)
$define(AOs::Console)
$define(AOs::Tacho)
$define(AOs::Blinke)

/*-- Interrupts */
$define(BSP::ISR::_U1RXInterrupt)
$define(BSP::ISR::_U1TXInterrupt)
$define(BSP::ISR::_U1ErrInterrupt)</text>
  </file>
  <file name="icbm.h">
   <text>/* Allegro A4960 BLDC test fixture main header */
#ifndef bldc_meter_h
#define bldc_meter_h

/* from MC controller RPM = (FG*720)/P*S */


#define REV &quot;0&quot;

enum BldcMeterSignals {                       /* signals used in the meter */
    
    TICK_SIG = Q_USER_SIG,
    WCOL_SIG,    //SPI write collision
    BLINK_SIG,
    ALARM_SIG,
    RUN_SIG,
    /**/
    TACHO_SIG,
    TACHO_TIMEOUT_SIG,
    RPM_SIG,
    FF_SIG,
    KBD_KEY_SIG,
    RBUT_PRESS_SIG,
    RBUT_RELEASE_SIG,
    BBUT_PRESS_SIG,
    BBUT_RELEASE_SIG
};
/* Access to A4960 fields */

/* active objects ..........................................................*/
extern struct Console  AO_Console;

$declare(AOs::Console_ctor)

#endif                                                      /* bldc_meter_h */</text>
  </file>
  <file name="qpn_port.h">
   <text>/* Allegro A4960 BLDC test fixture QP-nano port header */
#ifndef qpn_port_h
#define qpn_port_h

#define Q_NFSM
#define Q_NHSM
#define Q_PARAM_SIZE            4
#define QF_TIMEEVT_CTR_SIZE     2
//#define QF_MAX_TICK_RATE 4

/* maximum # active objects--must match EXACTLY the QF_active[] definition  */
#define QF_MAX_ACTIVE           1U

                         /* task-level interrupt nesting policy, see NOTE01 */
#define QF_INT_DISABLE()        __builtin_disi(0x3FFFU)
#define QF_INT_ENABLE()         __builtin_disi(0x0000U)

          /* ISR-level interrupt locking policy for PIC24/dsPIC, see NOTE02 */
#define QF_ISR_NEST

                           /* fast log-base-2 with FBCL instruction, NOTE03 */
#define QF_LOG2(n_) ((uint8_t)(15 + __builtin_fbcl(n_)))

             /* Exact-width types. WG14/N843 C99 Standard, Section 7.18.1.1 */
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;

#include &quot;qepn.h&quot;         /* QEP-nano platform-independent public interface */
#include &quot;qfn.h&quot;           /* QF-nano platform-independent public interface */


/*****************************************************************************
* NOTE01:
* The DISI (disable interrupts) instruction is used for very fast,
* unconditional locking and unlocking of interrupts. The DISI #0x3FFF
* instruction disables interrupts for 16383 instruction cycles, which is
* much longer than any critical section in QP-nano. The DISI #0 instruction
* is then used to unconditionally unlock the interrupts at the end of the
* critical section. The DISI instruction only disables interrupts with
* priority levels 1-6. Priority level 7 interrupts and all trap events still
* have the ability to interrupt the CPU when the DISI instruction is active.
* This means that from the perspective of QP-nano, the level 7 interrupts are
* treated as non-maskable interrupts (NMIs). Such non-maskable interrupts
* _cannot_ call any QP-nano services. In particular, they cannot post events.
*
* CAUTION: This QP-nano port assumes that interrupt nesting is _enabled_,
* which is the default in the PIC24/dsPIC processors. Interrupt nesting should
* never be disabled by setting the NSTDIS control bit (INTCON1&lt;15&gt;). If you
* don't want interrupts to nest, you can always prioritize them at the same
* level. For example, the default priority level for all interrupts is 4 out
* of reset. If you don't change this level for any interrupt the nesting of
* interrupt will not occur.
*
* NOTE02:
* The ISR-level interrupt policy allows interrupt nesting. The QF_ISR_KEY_TYPE
* is _not_ defined, which means that the ISRs will use the task-level
* interrupt locking policy. This is possible, because PIC245/dsPIC CPU does
* _not_ lock interrupts upon entry to the ISR, so the ISR does not constitute
* critical section and the simple critical section incapable of nesting is
* adequate.
*
* NOTE03:
* The FBCL instruction (Find First Bit Change Left) determines the exponent
* of a value by detecting the first bit change starting from the value’s sign
* bit and working towards the LSB. Since the PIC24/dsPIC’s barrel shifter
* uses negative values to specify a left shift, the FBCL instruction returns
* the negated exponent of a value. This value added to 15 gives the log-2.
*/

#endif                                                        /* qpn_port_h */</text>
  </file>
  <file name="README.md">
   <text>Interactive Controller for Brushless Motors source code

Alpha code - do not expect anything. Compiles on xc ver 1.23 but throws weird linker error
in 1.24. Have not tested on 1.25.</text>
  </file>
 </directory>
</model>
