/*****************************************************************************
* Model: icbm.qm
* File:  ./bsp.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::bsp.c} ..............................................................*/
/* Allegro A4960 BLDC test fixture board support package */
#include "qpn_port.h"
#include "bsp.h"
#include "icbm.h"
#include <libpic30.h>
//rev0 notes
//1.console on UART1
//SPI1
//CS on pin 25
//ICD on different pins

/* PIC24FV16KM202-specific */

/* MCU configuration bits                      */
/* external 8 MHz crystal w/PLL, 32MHz clock   */
#pragma config BWRP=OFF, BSS=OFF, GWRP=OFF, GCP=OFF
#pragma config FNOSC = PRIPLL, SOSCSRC = DIG, LPRCSEL = LP, IESO = ON
#pragma config POSCMOD = HS, OSCIOFNC = CLKO, POSCFREQ = MS, FCKSM = CSECME
#pragma config FWDTEN = OFF, WINDIS = OFF
#pragma config BOREN=BOR0, RETCFG=OFF, PWRTEN = OFF, MCLRE=ON
#pragma config ICS = PGx1

/* Local-scope objects -----------------------------------------------------*/
                             /* frequency of the oscillator for PIC24 */
#define FOSC_HZ                 32000000.0
                                       /* instruction cycle clock frequency */
#define FCY_HZ                  (FOSC_HZ / 2.0)



/* Peripherals                                -----------------------------*/
//inputs

#define CONS_RX_TRIS _TRISB2    //console
#define MISO_TRIS _TRISB10      //SPI
#define TACHO_TRIS _TRISB12     //OC to measure length of tacho
#define DIAG_TRIS  _TRISB9      //DIAG input

#define RBUT_MASK     _PORTB_RB5_MASK
#define RBUT_TRIS     _TRISB5    //RUN button
#define RBUT_PIN      _RB5
#define RBUT_PULLUP   _CN27PUE

#define BBUT_MASK     _PORTA_RA4_MASK
#define BBUT_TRIS     _TRISA4    //BRAKE button
#define BBUT_PIN      _RA4
#define BBUT_PULLUP   _CN0PUE

#define EBUT_MASK     _PORTB_RB3_MASK
#define EBUT_TRIS     _TRISB3    //Button on encoder shaft
#define EBUT_PIN      _RB3
#define EBUT_PULLUP   _CN7PUE

//it pays to keep encoder channels together
#define ENCA_MASK     _PORTA_RA0_MASK
#define ENCA_TRIS     _TRISA0   //Encoder A channel
#define ENCA_PIN      _RA0
#define ENCA_PULLUP   _CN2PUE

#define ENCB_MASK     _PORTA_RA1_MASK
#define ENCB_TRIS     _TRISA1    //Encoder B channel
#define ENCB_PIN      _RA1
#define ENCB_PULLUP   _CN3PUE

#define ENC_PORT      PORTA

/* High Endurance EEPROM        ------------------------------------------*/
#define EE_SIZE 256U                 //x16 bit
#define HEE_PAGES 4U                  //more than 2 to detect
                                     //failed pack
#define HEE_PAGESIZE EE_SIZE/HEE_PAGES

#define EE_ROW_SIZE 8U               //8 words erase max
#define EE_ROWS 8U

#define EE_ERASE_8    0x1a
#define EE_ERASE_4    0x19
#define EE_ERASE_1    0x18
#define EE_ERASE_ALL  0x10
#define EE_WRITE   0x04

//EEPROM Write queue size - must be power of 2
#define HEEQ_BUFSIZE 64
#define HEEQ_BUFMASK ( HEEQ_BUFSIZE - 1 )

#if ( HEEQ_BUFSIZE & HEEQ_BUFMASK )
#error EEPROM Write queue size is not a power of 2
#endif

typedef union
{
    uint8_t val;
    struct
    {
        unsigned addrNotFound:1;        // Return 0xFFFF
        unsigned expiredPage:1;               // Return 0x1
        unsigned packBeforePageFull:1;    // Not a return condition
        unsigned packBeforeInit:1;        // Return 0x3
        unsigned packSkipped:1;            // Return 0x4
        unsigned IllegalAddress:1;        // Return 0x5
        unsigned pageCorrupt:1;            // Return 0x6
        unsigned writeError:1;            // Return 0x7
    };
} HEE_FLAGS;

typedef struct __attribute__((__packed__)) heep_t {    //page status
    union {
        uint16_t val;
        struct {
            unsigned count:13;
            unsigned expired:1;
            unsigned available:1;
            unsigned current:1;
        };
    };
} HEE_PAGE_STATUS;

typedef struct heeq_t {    //EEPROM modification request
    uint16_t data;
    _prog_addressT addr;
    uint8_t op;
} HEE_REQ;

//todo: check if zeroing it at programming is certain
__eds__ const uint16_t heep[4][64] __attribute__((space(eedata), aligned(2)));


//EEPROM WR Queue
HEE_REQ heeq[HEEQ_BUFSIZE];
uint8_t heeq_Head;
volatile uint8_t heeq_Tail;    //interrupt changes this

/* A4960 */

#define A4960_CS_PIN _RB14


#define TIMER1_ISR_PRIO         4

//- Const

//Enable-disable messages
const char const zen[] = "\x08\x08\x08 0 - Enable, 1- Disable";

//Common units

const char const us[] = "us";    //microseconds
const char const ms[] = "ms";    //milliseconds
const char const pct[] = "%";    //percent

//- Static

//static uint8_t tach_ro;    //rollover count for Tacho

/* ISRs --------------------------------------------------------------------*/
/*${BSP::ISR::_AddressError} ...............................................*/
void __attribute__((__interrupt__,__no_auto_psv__)) _AddressError(void) {
    while(1);    //Address error
}
/*${BSP::ISR::_StackError} .................................................*/
void __attribute__((__interrupt__,__no_auto_psv__)) _StackError(void) {
    while(1);
}

//www.microchip.com/forums/FindPost/426711
/*${BSP::ISR::_T1Interrupt} ................................................*/
void __attribute__((__interrupt__, auto_psv)) _T1Interrupt(void) {
    #define KEYS ((portb & RBUT_MASK) | (portb & EBUT_MASK) | (porta & BBUT_MASK))

    typedef union {    //key specific
         uint8_t w;
         struct {
             unsigned : 3;
             unsigned ebut: 1;
             unsigned bbut: 1;
             unsigned rbut: 1;
         } __attribute__ ((__packed__));
     } Ku;

    static const int8_t const enc_states[] =         //encoder lookup table
        {0,ENCD_SIG,ENCI_SIG,0,ENCI_SIG,0,0,ENCD_SIG,ENCD_SIG,0,0,ENCI_SIG,0,ENCI_SIG,ENCD_SIG,0};

    static uint8_t old_AB = 0;    //previous state of the encoder
    static uint8_t deb_idx = 0;   //index to button debounce history
    static Ku kbd[4];             //button debounce history
    static Ku keys = {0};         //debounced keys
    Ku les = {0};                       //leading edges
    Ku tes = {0};                       //trailing edges
    Ku oldk;                      //prev.state of debounced keys

    uint16_t porta = PORTA;    //read encoder and buttons
    uint16_t portb = PORTB;

    //kbd[deb_idx].w = KEYS;  //store current state of the keys

    //process encoder
    old_AB <<= 2;                //remember previous state
    old_AB |= ( porta & 0x03 );  //add current state

    if( enc_states[(old_AB & 0x0f)]) { //encoder changed state
        QACTIVE_POST_X_ISR((QActive *)&AO_Console,
            1, enc_states[(old_AB & 0x0f)], 0U);
    }

    //process buttons
    deb_idx++;
    deb_idx &= 0x03;        //wrap
    kbd[deb_idx].w = KEYS;  //store current state of the keys
    oldk = keys;            //store previous state of debounced keys

    keys.w |= kbd[0].w & kbd[1].w & kbd[2].w & kbd[3].w;  // All on  - set
    keys.w &= kbd[0].w | kbd[1].w | kbd[2].w | kbd[3].w;  // All off - clear

    les.w |= (keys.w ^ oldk.w) & keys.w;     // or in new leading edges
    tes.w |= (keys.w ^ oldk.w) & ~keys.w;    // or in new trailing edges

    if(les.rbut) {
                      QACTIVE_POST_X_ISR((QActive *)&AO_Console, 1,
                            RBUT_RELEASE_SIG, 0);
    }

    if(les.bbut) {
                      QACTIVE_POST_X_ISR((QActive *)&AO_Console, 1,
                            BBUT_RELEASE_SIG, 0);
    }

    if(les.ebut) {
                      QACTIVE_POST_X_ISR((QActive *)&AO_Console, 1,
                            EBUT_RELEASE_SIG, 0);
    }

    if(tes.rbut) {
                      QACTIVE_POST_X_ISR((QActive *)&AO_Console, 1,
                            RBUT_PRESS_SIG, 0);
    }

    if(tes.bbut) {
                      QACTIVE_POST_X_ISR((QActive *)&AO_Console, 1,
                            BBUT_PRESS_SIG, 0);
    }

    if(tes.ebut) {
                      QACTIVE_POST_X_ISR((QActive *)&AO_Console, 1,
                            EBUT_PRESS_SIG, 0);
    }

    _T1IF = 0;                              /* clear Timer 1 interrupt flag */

    QACTIVE_POST_X_ISR((QActive*)&AO_Console, 1,
        TICK_SIG, 0U);

    QF_tickISR();                /* handle all armed time events in QF-nano */
}

/*${BSP::Tacho::_CCT3Interrupt} ............................................*/
void __attribute__((__interrupt__, auto_psv)) _CCT3Interrupt(void) {
    //tach_ro++;
    _CCT3IF = 0;
}
/*${BSP::Tacho::_CCP3Interrupt} ............................................*/
void __attribute__((__interrupt__, auto_psv)) _CCP3Interrupt(void) {
    uint32_t time,sps; //rotor steps per second, i.e., rps multiplied by # of pole pairs

    CCP3TMRL = 0;    //clear timer
    CCP3TMRH = 0;

    while(CCP3STATLbits.ICBNE) {    //data present

        time = ((CCP3BUFH << 8) | CCP3BUFL);
    }
        sps = FCY_HZ / (time*6);    //six pulses per step

    QACTIVE_POST_X_ISR ((QActive*)&AO_Console, 1,
        TACHO_SIG, sps);

    _CCP3IF = 0;
}

/*${BSP::HEE::_NVMInterrupt} ...............................................*/
void __attribute__((__interrupt__, auto_psv)) _NVMInterrupt(void) {
    if( heeq_Head != heeq_Tail ) {    //data available
                heeq_Tail++;
    #if HEEQ_BUFMASK < 255
                heeq_Tail &= HEEQ_BUFMASK;
    #endif

    // __ builtin_software_breakpoint();

        HEE_REQ req = heeq[heeq_Tail];

    //_prog_addressT p = req.addr;

        NVMCONbits.NVMOP = req.addr;
    //    TBLPAG = __builtin_tblpage(p);
    //    uint16_t offset = __builtin_tbloffset(&p);

        if(req.op == EE_WRITE) {
            // Write Data Value To Holding Latch
    //        __builtin_tblwtl(offset, req.data);
        }
        else {
    //        __builtin_tblwtl(offset, offset);
        }
        // Disable Interrupts For 5 Instructions
        asm volatile ("disi #5");
        // Issue Unlock Sequence & Start Write Cycle
        __builtin_write_NVM();
    }
    else { //queue empty
        _NVMIE = 0;
    }

    _NVMIF = 0;
}

/*${BSP::A4960::Common::SPI_init} ..........................................*/
static void SPI_init(void) {
    SSP1STATbits.CKE = 1;
    SSP1CON1bits.SSPM = 0b1010;
    SSP1ADD = 0x0f;    //1 MHz SPI clock
    SSP1CON1bits.SSPEN = 1; //enable SPI
    MISO_TRIS = 1;    //set MISO line to input
}
/*${BSP::A4960::Common::A4960_xfer} ........................................*/
uint16_t A4960_xfer(uint8_t reg, uint16_t data) {
    A4960_CS_PIN = 0;

    uint16_t tmpdata;

    SSP1BUF = ((reg << 4) | (data >> 8));    //send upper byte
    while(SSP1STATbits.BF == 0);    //wait till end of xfer

    tmpdata = SSP1BUF;

    SSP1BUF = data & 0xff;        //send lower byte

    tmpdata = tmpdata << 8;
    while(SSP1STATbits.BF == 0);    //wait till end of xfer

    tmpdata = (tmpdata | SSP1BUF);

    A4960_CS_PIN = 1;    //transfer done

    if((reg & 0x01) && (tmpdata & 0x8000)) {    //A4960 fault
    //    QACTIVE_POST_X((QActive*)&AO_Console, 1, FF_SIG,0U);
        QACTIVE_POST_X((QActive*)&AO_Console, 1, FF_SIG, tmpdata);
    };

    /* Look out for events */

    if(SSP1CON1bits.WCOL == 1) {    //write collision
        SSP1CON1bits.WCOL = 0;        //clear
        QACTIVE_POST_X((QActive*)&AO_Console, 1, WCOL_SIG,0U);
    }

    return tmpdata;
}
/*${BSP::A4960::Common::getField} ..........................................*/
uint16_t getField(FIELD* field) {
    uint16_t tmpdata = A4960_xfer(field->reg,0U);
    uint16_t tmpmask = field->mask;

    tmpdata &= tmpmask;    //clear the rest

    while((tmpmask & 0x01) == 0) {    //LSB equals 0
        tmpmask >>= 1;
        tmpdata >>= 1;
    };

    return(tmpdata);
}
/*${BSP::A4960::Common::setField} ..........................................*/
uint16_t setField(uint16_t val, FIELD* field) {
    uint16_t tmpdata = A4960_xfer(field->reg,0U);
    uint16_t tmpmask = field->mask;
    uint16_t tmpval = val;

    tmpdata &= ~tmpmask; //clear the field position

    while((tmpmask & 0x1) == 0) { //LSB equals 0
        tmpmask >>= 1;
        tmpval <<= 1;
    }

    tmpdata |= tmpval;            //insert field

    return(A4960_xfer(field->reg + 1, tmpdata));//write
}

/*${BSP::A4960::Common::convPercent} .......................................*/
static uint16_t convPercent(FIELD* field) {
    return((getField(field) + 1)*625U);
}
//- Limits
/*${BSP::A4960::Limits::ConvCommBlankTime} .................................*/
static uint16_t ConvCommBlankTime(FIELD* field) {
    const uint16_t const blanktimes[] = {50U,100U,400U,1000U};

    uint8_t tmpdata = getField(field);

    return(blanktimes[tmpdata]);
}
/*${BSP::A4960::Limits::ConvBlankTime} .....................................*/
static uint16_t ConvBlankTime(FIELD* field) {
    return(400U*getField(field));
}
/*${BSP::A4960::Limits::ConvDeadTime} ......................................*/
static uint16_t ConvDeadTime(FIELD* field) {
    uint16_t tmpdata = getField(field);

    return((tmpdata < 3) ? 100U : tmpdata*50U);
}
//- Common ConvPercent used for Curr.Sense Ratio
/*${BSP::A4960::Limits::ConvVdsThreshold} ..................................*/
static uint16_t ConvVdsThreshold(FIELD* field) {
    return(25U*getField(field));
}

/* Item access structure. Layout as follows:

name - what is printed in the menu
unit - what is printed after the value
point - decimal point
reg - register containing the item
mask - bitmask of an item inside the register
conv - function to convert contents to value
*/

FIELD const CommBlankTime =
    {"Commutation Blank Time", us, 0U, A4960_CONF0_RD, 0x0c00,
        &ConvCommBlankTime};

FIELD const BlankTime =
    {"Blank Time",us, 3U, A4960_CONF0_RD, 0x03c0,
        &ConvBlankTime};

FIELD const DeadTime =
    {"Dead Time","ns", 0U, A4960_CONF0_RD, 0x003f,
        &ConvDeadTime};

FIELD const CurrentSenseRefRatio =
    {"Current Sense",pct, 2U, A4960_CONF1_RD, 0x03c0,
        &convPercent};

FIELD const VdsThreshold =
    {"VDS Threshold","mV", 0U, A4960_CONF1_RD, 0x003f,
        &ConvVdsThreshold};

//- Run
/*${BSP::A4960::Run::ConvFixedOffTime} .....................................*/
static uint16_t ConvFixedOffTime(FIELD* field) {
    return(10+(getField(field)*16U));
}
/*${BSP::A4960::Run::ConvPhaseAdvance} .....................................*/
static uint16_t ConvPhaseAdvance(FIELD* field) {
    return(getField(field)*1875U); //deg(e), DS p.28
}
//BemfHyst - get
/*${BSP::A4960::Run::ConvBemfWindow} .......................................*/
static uint16_t ConvBemfWindow(FIELD* field) {
    return(0x04 << getField(field)); //us DS p.29
}
//Brake - get
//Direction - get
//Run - get


FIELD const FixedOffTime =
    {"Fixed Off Time",us, 1U, A4960_CONF2_RD, 0x001f, &ConvFixedOffTime};

FIELD const PhaseAdvance =
    {"Phase Advance","deg(e)", 3U, A4960_CONF5_RD, 0x0c00, &ConvPhaseAdvance};

FIELD const BemfHyst =
    {"BEMF Hysteresis","0 - Auto, 1 - None, 2 - High, 3 - Low", 0U, A4960_RUN_RD, 0x0c00,
        &getField};

FIELD const BemfWindow =
    {"BEMF Window",us, 0U, A4960_RUN_RD, 0x0380, &ConvBemfWindow};

FIELD const Brake =
    {"Brake","0 - Off, 1 - On", 0U, A4960_RUN_RD, 0x0004, &getField};

FIELD const Direction =
    {"Direction","0 - Fwd, 1 - Rev", 0U, A4960_RUN_RD, 0x0002, &getField};

FIELD const Run =
    {"Run","0 - Coast, 1 - Run", 0U, A4960_RUN_RD, 0x0001, &getField};

//Startup

//HoldTorque - percent
/*${BSP::A4960::Startup::ConvHoldTime} .....................................*/
static uint16_t ConvHoldTime(FIELD* field) {
    return(getField(field)*8 + 2); //ms DS p.27
}
/*${BSP::A4960::Startup::ConvEndCommTime} ..................................*/
static uint16_t ConvEndCommTime(FIELD* field) {
    return((getField(field) + 1)*2U); //ms, DS p.28
}
/*${BSP::A4960::Startup::ConvStartCommTime} ................................*/
static uint16_t ConvStartCommTime(FIELD* field) {
    return((getField(field) + 1)*8U); //ms, DS p.28
}
//ForcedCommTorque - A_ConvPercent
/*${BSP::A4960::Startup::ConvRampRate} .....................................*/
static uint16_t ConvRampRate(FIELD* field) {
    return((getField(field) + 1)*2U); //ms, DS p.28
}

FIELD const HoldTorque =
    {"Hold Torque", pct, 2U, A4960_CONF3_RD, 0x00f0, &convPercent};

FIELD const HoldTime =
    {"Hold Time",ms, 0U, A4960_CONF3_RD, 0x000f, &ConvHoldTime};

FIELD const EndCommTime =
    {"End Comm. Time",ms, 0U, A4960_CONF4_RD, 0x00f0, &ConvEndCommTime};

FIELD const StartCommTime =
    {"Start Comm. Time",ms, 0U, A4960_CONF4_RD, 0x000f, &ConvStartCommTime};

FIELD const ForcedCommTorque =
    {"Forced Comm. Ramp-up Torque",pct, 2U, A4960_CONF5_RD, 0x00f0, &convPercent};

FIELD const RampRate =
    {"Ramp Rate",ms, 1U, A4960_CONF5_RD, 0x000f, &ConvRampRate};

//Flags - all generic

FIELD const VaFlag =
    {"Bootcap A Fault", zen, 0U, A4960_MASK_RD, 0x0100, &getField};

FIELD const VbFlag =
    {"Bootcap B Fault", zen, 0U, A4960_MASK_RD, 0x0080, &getField};

FIELD const VcFlag =
    {"Bootcap C Fault", zen, 0U, A4960_MASK_RD, 0x0040, &getField};

FIELD const AhFlag =
    {"Phase A High-Side Fault", zen, 0U, A4960_MASK_RD, 0x0020, &getField};

FIELD const AlFlag =
    {"Phase A Low-Side Fault", zen, 0U, A4960_MASK_RD, 0x0010, &getField};

FIELD const BhFlag =
    {"Phase B High-Side Fault", zen, 0U, A4960_MASK_RD, 0x0008, &getField};

FIELD const BlFlag =
    {"Phase B Low-Side Fault", zen, 0U, A4960_MASK_RD, 0x0004, &getField};

FIELD const ChFlag =
    {"Phase C High-Side Fault", zen, 0U, A4960_MASK_RD, 0x0002, &getField};

FIELD const ClFlag =
    {"Phase C Low-Side Fault", zen, 0U, A4960_MASK_RD, 0x0001, &getField};

//- Misc all generic

FIELD const TorqueCtlMethod =
    {"Torque Control Method", "0 - Current, 1 - Duty Cycle", 0U, A4960_CONF3_RD, 0x0100,
        &getField};

FIELD const EnableStopOnFail =
    {"Stop on Fail", zen, 0U, A4960_RUN_RD, 0x0040, &getField};

FIELD const DiagOutput =
    {"Diag Output","0 - Flt, 1 - LOS, 2 -VDS Thr, 3 - clock", 0U, A4960_RUN_RD, 0x0030,
        &getField};

FIELD const RestartControl =
    {"Restart Control", zen, 0U, A4960_RUN_RD, 0x0080, &getField};

FIELD const TwFlag =
    {"Temperature Warning Fault", zen, 0U, A4960_MASK_RD, 0x0800,
        &getField};

FIELD const TsFlag =
    {"Thermal Shutdown Fault", zen, 0U, A4960_MASK_RD, 0x0400,
        &getField};

FIELD const LosFlag =
    {"BEMF Sync. Loss Fault", zen, 0U, A4960_MASK_RD, 0x0200,
        &getField};


//- PWM access

//One of the 8 pre-determined frequencies

static const uint16_t pwmPeriod[] = { 64000U, 32000U, 16000U,
    8000U, 3200U, 1600U, 800U, 320U };

static const uint16_t pwmFreq[] = { 250U, 500U, 1000U,
    2000U, 5000U, 10000U, 20000U, 50000U };

/*${BSP::PWM::PWM_init} ....................................................*/
static void PWM_init(void) {
    //_RA7 = 1;
    //return;

    CCP5CON1Lbits.CCSEL = 0;    //mode
    CCP5CON1Lbits.MOD = 0b0101;

    CCP5CON1Lbits.TMR32 = 0;    //timebase
    CCP5CON1Lbits.TMRSYNC = 0;
    CCP5CON1Lbits.CLKSEL = 0b000;
    CCP5CON1Lbits.TMRPS = 0b00;
    CCP5CON1Hbits.TRIGEN = 0;
    CCP5CON1Hbits.SYNC = 0b00000;

    CCP5CON2Hbits.OCAEN = 1;    //enable PWM on the output
    //CCP5CON3Hbits.OUTM = 0b000;
    //CCP5CON3Hbits.POLBDF = 0;    //active high
    CCP5CON3Hbits.POLACE = 0;
    //CCP5TMRL = 0xffff;
    CCP5PRL = 0x03ff;
    CCP5RA = 0x0000;
    CCP5RB = 0x01ff;
    CCP5CON1Lbits.CCPON = 1;
}
/*${BSP::PWM::PWM_idxLookup} ...............................................*/
static uint8_t PWM_idxLookup(const uint16_t* array, uint16_t val) {
    uint8_t i = 0;

    while( i < 8 ) {
        if(array[i] == val) {
            return(i);
        }
        i++;
    }

    return(0xff); //not found
}
/*${BSP::PWM::PWM_getPeriodIdx} ............................................*/
static uint16_t PWM_getPeriodIdx(ITEM* item) {
    return(PWM_idxLookup(pwmPeriod,CCP5PRL));
}

/*${BSP::PWM::PWM_getPeriod} ...............................................*/
uint16_t PWM_getPeriod(void) {
    return(CCP5PRL);
}
/*${BSP::PWM::PWM_setPeriod} ...............................................*/
uint16_t PWM_setPeriod(uint16_t val, ITEM* item) {
    return(CCP5PRL = pwmPeriod[val]);
}
/*${BSP::PWM::PWM_convFreq} ................................................*/
static uint16_t PWM_convFreq(ITEM* item) {
    return(pwmFreq[PWM_getPeriodIdx(item)]);
}
/*${BSP::PWM::PWM_getDuty} .................................................*/
uint16_t PWM_getDuty(void) {
    return(CCP5RB);
}
/*${BSP::PWM::PWM_setDuty} .................................................*/
void PWM_setDuty(uint16_t val) {
    CCP5RB = val;
}

ITEM const PWM_Freq =
    {"PWM Frequency", "kHz", 3U, 0U, 0x07,
        &PWM_getPeriodIdx, &PWM_setPeriod, &PWM_convFreq};

ITEM const PWM_Duty =
    {"PWM Duty Cycle", "%", 0U, 0U, 0x00,
        &PWM_getDuty, &PWM_setDuty, &PWM_getDuty};


/*${BSP::HEE::HEE_init} ....................................................*/
static void HEE_init(void) {
    NVMCONbits.PGMONLY = 1;
    _NVMIP = 1;    //priority
}

/*${BSP::Tacho::Tacho_init} ................................................*/
static void Tacho_init(void) {
    CCP3CON1Lbits.CCPON = 0;   //disable
    CCP3CON1Lbits.CCSEL = 1;   //input capture mode
    CCP3CON1Lbits.CLKSEL = 0;  //sysclk
    CCP3CON1Lbits.TMR32 = 1;   //32-bit mode
    CCP3CON1Lbits.MOD = 1;     //rising every rising edge
    CCP3CON2Hbits.ICSEL = 0;   //rising edge
    CCP3CON1Hbits.IOPS = 0;    //interrupt on every event
    CCP3CON1Lbits.TMRPS = 0;   //prescaler
    CCP3CON1Lbits.CCPON = 1;   //enable

    //_CCT3IP = 1;    //tacho timer interrupt priority
                    //must be lower than tacho capture
    _CCP3IP = 6;    //tacho capture interrupt priority
}
/*${BSP::BSP_init} .........................................................*/
void BSP_init(void) {
    RCONbits.SWDTEN = 0; /* disable Watchdog */

    TRISA = 0x00;        /* set all pins as dig.outputs */
    PORTA = 0x00;
    TRISB = 0x00;
    PORTB = 0x00;
    ANSA = 0x00;
    ANSB = 0x00;

    CONS_RX_TRIS = 1;    //inputs
    TACHO_TRIS = 1;
    DIAG_TRIS = 1;
    RBUT_TRIS = 1;
    BBUT_TRIS = 1;
    EBUT_TRIS = 1;
    ENCA_TRIS = 1;
    ENCB_TRIS = 1;
    RBUT_PULLUP = 1;    //pullups on mechanical inputs
    BBUT_PULLUP = 1;
    EBUT_PULLUP = 1;
    ENCA_PULLUP = 1;
    ENCB_PULLUP = 1;

    SPI_init();
    PWM_init();
    Tacho_init();
    HEE_init();

}
/*${BSP::QPn::QF_onStartup} ................................................*/
void QF_onStartup(void) {
    T1CON = 0x0000U;  /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1 */
    TMR1  = 0x0000U; /* Start counting from 0 and clear the prescaler count */
    PR1   = (uint16_t)((FCY_HZ / BSP_TICKS_PER_SEC) - 1.0 + 0.5); /* period */
    _T1IP = TIMER1_ISR_PRIO;              /* set Timer 2 interrupt priority */
    _T1IF = 0;                           /* clear the interrupt for Timer 1 */
    _T1IE = 1;                              /* enable interrupt for Timer 1 */
    T1CONbits.TON = 1;                                     /* start Timer 1 */

    /* Enable peripheral interrupts as late as possible */
    //_CCT3IE = 1;    //tacho timer
    _CCP3IE = 1;    //tacho capture
    _U1RXIE = 1;                                     /* Console on UART1 Rx */
    _NVMIE = 1;            //EEPROM
}

/*****************************************************************************
* NOTE01:
* The callback function QF_onIdle() is called with interrupts disabled,
* because the idle condition can be invalidated by any enabled interrupt
* that would post events. The QF_onIdle() function *must* enable interrupts
* internally
*
* NOTE02:
* To be on the safe side, the DISICNT counter is set to just 1 cycle just
* before entering the Idle mode (or Sleep mode, if you choose). This way,
* interrupts (with priorities 1-6) get enabled at the same time as the
* transition to the low-power mode.
*/
/*${BSP::QPn::QF_onIdle} ...................................................*/
void QF_onIdle(void) {
    //LED_ON ();
    //LED_OFF();

    #ifdef NDEBUG
        __asm__ volatile("disi #0x0001");
        Idle();                          /* transition to Idle mode, see NOTE02 */
    #else
        QF_INT_ENABLE();                       /* enable interrupts, see NOTE01 */
    #endif
}
/*${BSP::QPn::Q_onAssert} ..................................................*/
void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line) {
    (void)file;                                   /* avoid compiler warning */
    (void)line;                                   /* avoid compiler warning */
    QF_INT_DISABLE();             /* make sure that interrupts are disabled */
    for (;;) {
    }
}

